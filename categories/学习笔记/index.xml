<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>学习笔记 on I&#39;m Groooooot</title>
    <link>https://lovemma.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 学习笔记 on I&#39;m Groooooot</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 29 Jun 2018 13:26:54 +0000</lastBuildDate>
    
	<atom:link href="https://lovemma.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>「Python3学习笔记」读书笔记—集合</title>
      <link>https://lovemma.github.io/posts/python3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E9%9B%86%E5%90%88/</link>
      <pubDate>Fri, 29 Jun 2018 13:26:54 +0000</pubDate>
      
      <guid>https://lovemma.github.io/posts/python3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E9%9B%86%E5%90%88/</guid>
      <description>集合存储的是非重复对象，所谓的非重复对象是指：除了不是同一对象外，值也不能相同。 # Python集合判重公式 (a is b) OR (hash(a) == hash(b) AND a == b) 如果不是同一对象，那么先判断哈希值，然后比较内容。因为受限于哈希算法，不同内容可能返回相同的哈希值（哈希碰撞），那么就有必要继续比较内容是否相同。 那么为什么要先比较哈希值，而不直接比较内容呢？首先，与大多数内容（例如字符串）相比，整数哈希值比较的性能高得多；其次，哈希值不</description>
    </item>
    
    <item>
      <title>「Python3学习笔记」读书笔记—字典</title>
      <link>https://lovemma.github.io/posts/python3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%AD%97%E5%85%B8/</link>
      <pubDate>Mon, 25 Jun 2018 22:59:09 +0000</pubDate>
      
      <guid>https://lovemma.github.io/posts/python3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%AD%97%E5%85%B8/</guid>
      <description>字典是内置类型中唯一的映射（Mapping）结构，基于哈希表存储键值对数据。 值可以是任意类型的数据，但主键必须是可哈希的类型。常见的可变类型，如列表、集合等都不能作为主键使用。即便是元组等不可变类型，也不能引用可变类型元素，即元组中不能含有可变类型的元素。 &amp;gt;&amp;gt;&amp;gt; import collections &amp;gt;&amp;gt;&amp;gt; issubclass(list, collections.Hashable) False &amp;gt;&amp;gt;&amp;gt; issubclass(int, collections.Hashable) True &amp;gt;&amp;gt;&amp;gt; hash((1, 2, 3)) 2528502973977326415 &amp;gt;&amp;gt;&amp;gt; hash((1, 2, [1, 2])) # 包含可变类型 Traceback (most recent call last): File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt; TypeError: unhashable type: &#39;list&#39; 哈希计算通过调用 __hash__ 方法返回整数值，用来快速比较内容是否相同</description>
    </item>
    
    <item>
      <title>「Python3学习笔记」读书笔记—列表</title>
      <link>https://lovemma.github.io/posts/python3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%88%97%E8%A1%A8/</link>
      <pubDate>Fri, 22 Jun 2018 00:00:18 +0000</pubDate>
      
      <guid>https://lovemma.github.io/posts/python3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%88%97%E8%A1%A8/</guid>
      <description>Python 中的 list 类型应该是我们平时用的最多一个数据类型，如果仅从操作方式上看，列表像是数组和链表的综合体，除了按索引访问外，还支持插入、追加、删除等操作，完全可以当作队列或栈来使用，因此，如果不考虑性能问题，列表是一种易用且功能完善的理想数据结构。 列表的内部结构由两部分构成：(1) 保存元素数量和内存分配计数的头部，(2) 存储元素指针的独立数组。所有的元素使用该数组来保存指针引用，并不嵌入实际的内容。 &amp;gt; 作为</description>
    </item>
    
    <item>
      <title>「Python3学习笔记」读书笔记—字节数组</title>
      <link>https://lovemma.github.io/posts/python3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 21 Jun 2018 09:23:35 +0000</pubDate>
      
      <guid>https://lovemma.github.io/posts/python3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84/</guid>
      <description>生物都是由细胞构成的，但在我们普通人眼中，并不会将鸡、鸭、狗、鸟这些动物当作细胞看待，因为对待事物的角度决定了我们更关心生物的外在形状和行为，而不是它的组织构成。 从计算机底层实现来说，所有的数据都是二进制字节序列。但为了更好地表达某个逻辑，计算机科学家们将数据抽象成不同的类型，犹如细胞和动物的关系。在编程语言中，对于字节序列，我们更关心的是它的存储和传输方式；而面向对象时，则着重于它的抽象属性。尽</description>
    </item>
    
    <item>
      <title>「Python3学习笔记」读书笔记—字符串</title>
      <link>https://lovemma.github.io/posts/python3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 14 Jun 2018 21:26:35 +0000</pubDate>
      
      <guid>https://lovemma.github.io/posts/python3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>字符串字面量以成对的单引号（`）、双引号（”），或可跨行的三引号（”””）语法构成，自动合并相邻的字面量。字符串支持转义、八进制、十六进制，或 Unicode 格式字符。 使用单引号还是双引号，并没有什么特殊限制。如果文本内的引用文字使用双引号，那么外面用单引号可避免转义，更易阅读。 &amp;gt; 通常情况下，建议遵循多数编程语言惯例，使用双引号标示。 Python 3 中字符串存储的是 Unicode 文本，是不可变序列类型。而 Unicode 格式大小写分别表示 16 位（ \u ）</description>
    </item>
    
    <item>
      <title>「Python3学习笔记」读书笔记--float类型</title>
      <link>https://lovemma.github.io/posts/python3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-float%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 09 Jun 2018 16:21:07 +0000</pubDate>
      
      <guid>https://lovemma.github.io/posts/python3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-float%E7%B1%BB%E5%9E%8B/</guid>
      <description>本文为「Python3学习笔记」一书的读书总结，以后每学习完一小节做一次记录。 在Python中 float 类型默认存储双精度浮点数（也就是其他语言中的 double ），可一表达16到17位浮点数。 &amp;gt;&amp;gt;&amp;gt; 1/3 0.3333333333333333 &amp;gt;&amp;gt;&amp;gt; 0.1234567890123456789 0.12345678901234568 从实现方式上来看，浮点数是以二进制的方式来存储十进制数的近似值。这就可能导致执行的结果与预期不符合，造成不一致缺陷。所以，在对精度有严格要求的场合，应该选择使用固定精度类型，如：decimal.Decimal 。 可通</description>
    </item>
    
  </channel>
</rss>