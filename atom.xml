<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>茂林修竹</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lovemma.github.io/"/>
  <updated>2019-09-18T06:03:53.738Z</updated>
  <id>https://lovemma.github.io/</id>
  
  <author>
    <name>COldish</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Celery 4.2 内存泄漏问题</title>
    <link href="https://lovemma.github.io/2019/09/18/Memory-Leak-in-Celery-4-2/"/>
    <id>https://lovemma.github.io/2019/09/18/Memory-Leak-in-Celery-4-2/</id>
    <published>2019-09-18T02:58:12.000Z</published>
    <updated>2019-09-18T06:03:53.738Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 Celery 4.2 版本时，遇到了内存泄漏问题，话不多说先上运行环境：</p><ul><li>Python 版本：2.7.5</li><li>Celery 版本：4.2.2</li><li>系统：CentOS</li></ul><a id="more"></a><h2 id="AsyncTask-的内存泄漏"><a href="#AsyncTask-的内存泄漏" class="headerlink" title="AsyncTask 的内存泄漏"></a>AsyncTask 的内存泄漏</h2><p>开发环境跑了一段时间之后，出现发布任务的 service 内存占用很高，而且会出现任务发布不了的情况。但发布任务的 service 并没有做什么太过复杂的操作，经过分析之后，将问题定位在了 <code>chord</code> 函数中会使用了 <code>apply_async</code> 来插入大量的 task。</p><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>写了一个简单的测试脚本来测试 <code>chord</code> :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> resource</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery, chord</span><br><span class="line"></span><br><span class="line">backend_url = <span class="string">'redis://redis:6379/1'</span></span><br><span class="line">broker_url = <span class="string">'pyamqp://rabbitmq:5672//?heartbeat=30'</span></span><br><span class="line">app = Celery(<span class="string">'task'</span>, broker=broker_url, backend=backend_url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dummy</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">result</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_mem</span><span class="params">()</span>:</span></span><br><span class="line">    print(</span><br><span class="line">        <span class="string">'Memory usage: &#123;&#125; (kb)'</span>.format(</span><br><span class="line">            resource.getrusage(resource.RUSAGE_SELF).ru_maxrss)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">        chord(dummy.si())(result.si())</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">            print_mem()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>每执行 1000 次打印一下内存占用情况，这个脚本在 Celery 4.2.2 版本里内存飞速增长。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Memory usage: 28041216 (kb)</span><br><span class="line">Memory usage: 43773952 (kb)</span><br><span class="line">Memory usage: 59592704 (kb)</span><br><span class="line">Memory usage: 75333632 (kb)</span><br><span class="line">Memory usage: 90955776 (kb)</span><br><span class="line">Memory usage: 106758144 (kb)</span><br><span class="line">Memory usage: 124145664 (kb)</span><br><span class="line">Memory usage: 139677696 (kb)</span><br><span class="line">Memory usage: 155234304 (kb)</span><br><span class="line">Memory usage: 170778624 (kb)</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在使用 <code>objgraph</code> 进行检测之后发现，内存中驻留了大量的 <code>promise</code> 和 <code>AsyncResult</code> ，继续 debug 下去可以发现问题是在这一行 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NlbGVyeS9jZWxlcnkvYmxvYi92NC4yLjIvY2VsZXJ5L3Jlc3VsdC5weSNMMTAy" title="https://github.com/celery/celery/blob/v4.2.2/celery/result.py#L102">https://github.com/celery/celery/blob/v4.2.2/celery/result.py#L102<i class="fa fa-external-link"></i></span> ，去掉 <code>self.on_ready = promise(self._on_fulfilled)</code> 后内存就能被回收了。而这个 <code>promise</code> 有个 <code>weak</code> 参数, 设置成 True 之后就会创建 <code>self._on_fulfilled</code> 的弱引用，<code>AsyncResult</code> 也能被回收，那 weak 改成 True 就对了吗?</p><p>然而并不是，搜了一下发现 Celery 以前的一个PR：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NlbGVyeS9jZWxlcnkvcHVsbC80MTMx" title="https://github.com/celery/celery/pull/4131">Removing weak-references in promises to bound methods (Fixes #3813) #4131<i class="fa fa-external-link"></i></span>，当时这段代码是设置了 <code>weak=True</code> 的，为什么要把 <code>weak=True</code> 删掉呢？因为传入的 <code>self._on_fulfilled</code> 是 <code>AsyncResult</code> 对象的 bound method，<code>weak.ref</code> 无法处理，后续尝试获取引用的时候总会得到 None，当时的 PR 就是为了解决 <code>self._on_fulfilled</code> 不会被执行的问题. 要对 bound method 做弱引用需要使用 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9saWJyYXJ5L3dlYWtyZWYuaHRtbCN3ZWFrcmVmLldlYWtNZXRob2Q=" title="https://docs.python.org/3/library/weakref.html#weakref.WeakMethod">WeakMethod<i class="fa fa-external-link"></i></span>，但这个在 Python 3.4 版本才开始有。</p><p>好了，回到之前的问题，那么内存泄漏是哪里来的呢？</p><p><code>AsyncResult</code> 中确实有循环引用， <code>AsyncResult -&gt; self.on_ready -&gt; promise -&gt; self._on_fulfilled -&gt; self</code>，引用计数算法对于循环引用的对象是无法回收的，而标记清除可以，但 <code>AsyncResult</code> 这个类还定义了 <code>__del__</code> 方法，这会让 Python 的 gc 在处理循环引用的对象时不知道该以什么顺序去运行他们的 <code>__del__</code> 方法, 这些对象就会一直驻留在内存里，具体可看这篇文章: <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMi9saWJyYXJ5L2djLmh0bWwjZ2MuZ2FyYmFnZQ==" title="https://docs.python.org/2/library/gc.html#gc.garbage">gc.garbage<i class="fa fa-external-link"></i></span></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>最简单粗暴的方案是将 <code>__del__</code> 方法删除掉，这样 Python 的 gc 就可以正确处理循环引用的对象了；</li><li>官方解决方案：把 WeakMethod backport 到 celery 用到的异步库 vine 里去: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NlbGVyeS92aW5lL2lzc3Vlcy8yMQ==" title="https://github.com/celery/vine/issues/21">https://github.com/celery/vine/issues/21<i class="fa fa-external-link"></i></span> ，这样在 celery 那头设置 <code>weak=True</code> 就能正确处理了。简单来说就是将 Celery 升级到 4.3.0 版本。</li></ol><p>参考链接</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NlbGVyeS9jZWxlcnkvcHVsbC80ODM5" title="https://github.com/celery/celery/pull/4839">Fix memory leak of AsyncResult #4839<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NlbGVyeS9jZWxlcnkvcHVsbC80MTMx" title="https://github.com/celery/celery/pull/4131">Removing weak-references in promises to bound methods (Fixes #3813) #4131<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9saWJyYXJ5L3dlYWtyZWYuaHRtbCN3ZWFrcmVmLldlYWtNZXRob2Q=" title="https://docs.python.org/3/library/weakref.html#weakref.WeakMethod">Python WeakMethod<i class="fa fa-external-link"></i></span></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 Celery 4.2 版本时，遇到了内存泄漏问题，话不多说先上运行环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python 版本：2.7.5&lt;/li&gt;
&lt;li&gt;Celery 版本：4.2.2&lt;/li&gt;
&lt;li&gt;系统：CentOS&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://lovemma.github.io/tags/Python/"/>
    
      <category term="Celery" scheme="https://lovemma.github.io/tags/Celery/"/>
    
  </entry>
  
  <entry>
    <title>Python 如何流式读取大文件</title>
    <link href="https://lovemma.github.io/2019/06/23/Python-%E5%A6%82%E4%BD%95%E6%B5%81%E5%BC%8F%E8%AF%BB%E5%8F%96%E5%A4%A7%E6%96%87%E4%BB%B6/"/>
    <id>https://lovemma.github.io/2019/06/23/Python-如何流式读取大文件/</id>
    <published>2019-06-23T13:28:52.000Z</published>
    <updated>2019-06-23T13:42:48.592Z</updated>
    
    <content type="html"><![CDATA[<p>几乎所有人都知道，在 Python 里读取文件有一种“标准做法”：首先使用 <code>with open(fine_name)</code> 上下文管理器的方式获得一个文件对象，然后使用 <code>for</code> 循环迭代它，逐行获取文件里的内容。</p><p>下面是一个使用这种“标准做法”的简单示例函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_nine</span><span class="params">(fname)</span>:</span></span><br><span class="line">    <span class="string">"""计算文件里包含多少个数字 '9'</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> open(fname) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">            count += line.count(<span class="string">'9'</span>)</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>假如我们有一个文件 <code>small_file.txt</code>，那么使用这个函数可以轻松计算出 9 的数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># small_file.txt</span></span><br><span class="line">feiowe9322nasd9233rl</span><br><span class="line">aoeijfiowejf8322kaf9a</span><br><span class="line"></span><br><span class="line"><span class="comment"># OUTPUT: 3</span></span><br><span class="line">print(count_nine(<span class="string">'small_file.txt'</span>))</span><br></pre></td></tr></table></figure><p>为什么这种文件读取方式会成为标准？这是因为它有两个好处：</p><ol><li><code>with</code> 上下文管理器会自动关闭打开的文件描述符</li><li>在迭代文件对象时，内容是一行一行返回的，不会占用太多内存</li></ol><a id="more"></a><h3 id="标准做法的缺点"><a href="#标准做法的缺点" class="headerlink" title="标准做法的缺点"></a>标准做法的缺点</h3><p>但这套标准做法并非没有缺点。如果被读取的文件里，根本就没有任何换行符，那么上面的第二个好处就不成立了。<strong>当代码执行到 <code>for line in file</code> 时，line 将会变成一个非常巨大的字符串对象，消耗掉非常可观的内存。</strong></p><p>让我们来做个试验：有一个 <strong>5GB</strong> 大的文件 <code>big_file.txt</code>，它里面装满了和 <code>small_file.txt</code> 一样的随机字符串。只不过它存储内容的方式稍有不同，所有的文本都被放在了同一行里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FILE: big_file.txt</span></span><br><span class="line">df2if283rkwefh... &lt;剩余 <span class="number">5</span>GB 大小&gt; ...</span><br></pre></td></tr></table></figure><p>如果我们继续使用前面的 <code>count_nine</code> 函数去统计这个大文件里 <code>9</code> 的个数。那么在我的笔记本上，这个过程会足足花掉 65 秒，并在执行过程中吃掉机器 2GB 内存<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p><h3 id="使用-read-方法分块读取"><a href="#使用-read-方法分块读取" class="headerlink" title="使用 read 方法分块读取"></a>使用 read 方法分块读取</h3><p>为了解决这个问题，我们需要暂时把这个“标准做法”放到一边，使用更底层的 <code>file.read()</code> 方法。与直接循环迭代文件对象不同，每次调用 <code>file.read(chunk_size)</code> 会直接返回从当前位置往后读取 <code>chunk_size</code> 大小的文件内容，不必等待任何换行符出现。</p><p>所以，如果使用 <code>file.read()</code> 方法，我们的函数可以改写成这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_nine_v2</span><span class="params">(fname)</span>:</span></span><br><span class="line">    <span class="string">"""计算文件里包含多少个数字 '9'，每次读取 8kb</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    block_size = <span class="number">1024</span> * <span class="number">8</span></span><br><span class="line">    <span class="keyword">with</span> open(fname) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            chunk = fp.read(block_size)</span><br><span class="line">            <span class="comment"># 当文件没有更多内容时，read 调用将会返回空字符串 ''</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            count += chunk.count(<span class="string">'9'</span>)</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>在新函数中，我们使用了一个 <code>while</code> 循环来读取文件内容，每次最多读取 8kb 大小，这样可以避免之前需要拼接一个巨大字符串的过程，把内存占用降低非常多。</p><h3 id="利用生成器解耦代码"><a href="#利用生成器解耦代码" class="headerlink" title="利用生成器解耦代码"></a>利用生成器解耦代码</h3><p>假如我们在讨论的不是 Python，而是其他编程语言。那么可以说上面的代码已经很好了。但是如果你认真分析一下 <code>count_nine_v2</code> 函数，你会发现在循环体内部，存在着两个独立的逻辑：<strong>数据生成（read 调用与 chunk 判断）</strong> 与 <strong>数据消费</strong>。而这两个独立逻辑被耦合在了一起。</p><p>为了提升复用能力，我们可以定义一个新的 <code>chunked_file_reader</code> 生成器函数，由它来负责所有与“数据生成”相关的逻辑。这样 <code>count_nine_v3</code> 里面的主循环就只需要负责计数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chunked_file_reader</span><span class="params">(fp, block_size=<span class="number">1024</span> * <span class="number">8</span>)</span>:</span></span><br><span class="line">    <span class="string">"""生成器函数：分块读取文件内容</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        chunk = fp.read(block_size)</span><br><span class="line">        <span class="comment"># 当文件没有更多内容时，read 调用将会返回空字符串 ''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">yield</span> chunk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_nine_v3</span><span class="params">(fname)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> open(fname) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> chunked_file_reader(fp):</span><br><span class="line">            count += chunk.count(<span class="string">'9'</span>)</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>进行到这一步，代码似乎已经没有优化的空间了，但其实不然。<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI2l0ZXI=" title="https://docs.python.org/3/library/functions.html#iter">iter(iterable)<i class="fa fa-external-link"></i></span> 是一个用来构造迭代器的内建函数，但它还有一个更少人知道的用法。当我们使用 <code>iter(callable, sentinel)</code> 的方式调用它时，会返回一个特殊的对象，迭代它将不断产生可调用对象 callable 的调用结果，直到结果为 setinel 时，迭代终止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chunked_file_reader</span><span class="params">(file, block_size=<span class="number">1024</span> * <span class="number">8</span>)</span>:</span></span><br><span class="line">    <span class="string">"""生成器函数：分块读取文件内容，使用 iter 函数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 首先使用 partial(fp.read, block_size) 构造一个新的无需参数的函数</span></span><br><span class="line">    <span class="comment"># 循环将不断返回 fp.read(block_size) 调用结果，直到其为 '' 时终止</span></span><br><span class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> iter(partial(file.read, block_size), <span class="string">''</span>):</span><br><span class="line">        <span class="keyword">yield</span> chunk</span><br></pre></td></tr></table></figure><p>最终，只需要两行代码，我们就完成了一个可复用的分块文件读取函数。那么，这个函数在性能方面的表现如何呢？</p><p>和一开始的 2GB 内存/耗时 65 秒 相比，使用生成器的版本只需要 7MB 内存 / 12 秒就能完成计算。效率提升了接近 4 倍，内存占用更是不到原来的 1%。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">视机器空闲内存而定，可能会耗费更多的内存</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几乎所有人都知道，在 Python 里读取文件有一种“标准做法”：首先使用 &lt;code&gt;with open(fine_name)&lt;/code&gt; 上下文管理器的方式获得一个文件对象，然后使用 &lt;code&gt;for&lt;/code&gt; 循环迭代它，逐行获取文件里的内容。&lt;/p&gt;
&lt;p&gt;下面是一个使用这种“标准做法”的简单示例函数：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;count_nine&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(fname)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;计算文件里包含多少个数字 &#39;9&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    &quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    count = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; open(fname) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; file:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; file:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            count += line.count(&lt;span class=&quot;string&quot;&gt;&#39;9&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; count&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假如我们有一个文件 &lt;code&gt;small_file.txt&lt;/code&gt;，那么使用这个函数可以轻松计算出 9 的数量。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# small_file.txt&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;feiowe9322nasd9233rl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;aoeijfiowejf8322kaf9a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# OUTPUT: 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(count_nine(&lt;span class=&quot;string&quot;&gt;&#39;small_file.txt&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为什么这种文件读取方式会成为标准？这是因为它有两个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;with&lt;/code&gt; 上下文管理器会自动关闭打开的文件描述符&lt;/li&gt;
&lt;li&gt;在迭代文件对象时，内容是一行一行返回的，不会占用太多内存&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lovemma.github.io/categories/Python/"/>
    
    
      <category term="Python技巧" scheme="https://lovemma.github.io/tags/Python%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>MySQL如何在给定场景下为一个用户授权?</title>
    <link href="https://lovemma.github.io/2019/05/24/MySQL%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BB%99%E5%AE%9A%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%BA%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83/"/>
    <id>https://lovemma.github.io/2019/05/24/MySQL如何在给定场景下为一个用户授权/</id>
    <published>2019-05-24T07:16:35.000Z</published>
    <updated>2019-05-24T08:07:57.182Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何定义-MySQL-数据库账号？"><a href="#如何定义-MySQL-数据库账号？" class="headerlink" title="如何定义 MySQL 数据库账号？"></a>如何定义 MySQL 数据库账号？</h3><ul><li><p>用户名的组成：用户名@可访问控制列表</p><ul><li><p>用户名：5.7版本以前，用户名最大只有16个字节；之后的版本为 32 个字节</p></li><li><p>可访问控制列表：用户可以从哪些服务器上对数据库进行访问</p><ol><li>%：代表可以从所有外部主机进行访问</li><li>192.168.1.%：可以从 192.168.1 网段进行访问</li><li>localhost：DB 服务器本地访问</li></ol></li></ul></li><li><p>使用 CREATE USER 命令建立用户</p></li></ul><a id="more"></a><h3 id="MySQL-常用的用户权限"><a href="#MySQL-常用的用户权限" class="headerlink" title="MySQL 常用的用户权限"></a>MySQL 常用的用户权限</h3><p>常用的权限如下表所示：</p><table><thead><tr><th>类别</th><th>语句</th><th>说明</th></tr></thead><tbody><tr><td>Admin</td><td>Create User</td><td>建立新的用户</td></tr><tr><td></td><td>Grant option</td><td>为其他用户授予权限</td></tr><tr><td></td><td>Super</td><td>管理服务器的权限</td></tr><tr><td>DDL</td><td>Create</td><td>新建数据库、表</td></tr><tr><td></td><td>Alter</td><td>修改表结构</td></tr><tr><td></td><td>Drop</td><td>删除数据库和表</td></tr><tr><td></td><td>Index</td><td>建立和删除索引</td></tr><tr><td>DML</td><td>Select</td><td>查询表中数据</td></tr><tr><td></td><td>Insert</td><td>插入数据</td></tr><tr><td></td><td>Update</td><td>更新数据</td></tr><tr><td></td><td>Delete</td><td>删除数据</td></tr><tr><td></td><td>Execute</td><td>执行存储过程</td></tr></tbody></table><p>通常开发人员只具有 DML 类的权限，如果想查看详细的权限列表，可执行命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><h3 id="何如为用户授权？"><a href="#何如为用户授权？" class="headerlink" title="何如为用户授权？"></a>何如为用户授权？</h3><ul><li><p>遵循最小权限原则，如：一个用户只具有只读权限，就不能授予除 <strong>select</strong> 之外的权限。</p></li><li><p>使用 Grant 命令对用户授权</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限 <span class="keyword">on</span> 数据库.表 <span class="keyword">to</span> 用户(<span class="keyword">user</span>@ip);</span><br><span class="line"><span class="comment"># 回收权限</span></span><br><span class="line"><span class="keyword">revoke</span> 权限 <span class="keyword">on</span> 数据库.表 <span class="keyword">from</span> 用户(<span class="keyword">user</span>@ip);</span><br></pre></td></tr></table></figure></li></ul><p>最后，若要查看 MySQL 命令的具体用法，如该命令有哪些参数等，可通过 <code>\h 命令</code> 来查看。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何定义-MySQL-数据库账号？&quot;&gt;&lt;a href=&quot;#如何定义-MySQL-数据库账号？&quot; class=&quot;headerlink&quot; title=&quot;如何定义 MySQL 数据库账号？&quot;&gt;&lt;/a&gt;如何定义 MySQL 数据库账号？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用户名的组成：用户名@可访问控制列表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用户名：5.7版本以前，用户名最大只有16个字节；之后的版本为 32 个字节&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可访问控制列表：用户可以从哪些服务器上对数据库进行访问&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;%：代表可以从所有外部主机进行访问&lt;/li&gt;
&lt;li&gt;192.168.1.%：可以从 192.168.1 网段进行访问&lt;/li&gt;
&lt;li&gt;localhost：DB 服务器本地访问&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 CREATE USER 命令建立用户&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://lovemma.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL用户授权" scheme="https://lovemma.github.io/tags/MySQL%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>通过list()和[]创建空列表的差异</title>
    <link href="https://lovemma.github.io/2019/05/22/%E9%80%9A%E8%BF%87list-%E5%92%8C-%E5%88%9B%E5%BB%BA%E7%A9%BA%E5%88%97%E8%A1%A8%E7%9A%84%E5%B7%AE%E5%BC%82/"/>
    <id>https://lovemma.github.io/2019/05/22/通过list-和-创建空列表的差异/</id>
    <published>2019-05-22T15:26:39.000Z</published>
    <updated>2019-05-23T01:10:12.228Z</updated>
    
    <content type="html"><![CDATA[<p>我们想创建一个空列表，可以使用如下两种方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># option A</span></span><br><span class="line">empty_list = list()</span><br><span class="line"></span><br><span class="line"><span class="comment"># option B</span></span><br><span class="line">empty_list = []</span><br></pre></td></tr></table></figure><p>但你有没有想过它们之间在效率上会不会有什么不同呢？我们应该优先使用哪种方式呢？</p><a id="more"></a><p>最近，看文章碰到了这个问题，就研究了一下，通过命令测试下它们的效率，结果如图</p><p><img src="Jietu20190522-232506.png" alt="list[]和[]的效率差别"></p><p>可以看到通过 <code>[]</code> 创建列表明显要比 <code>list()</code> 快，这是为什么呢？</p><p>用 <code>list()</code> 方法构造一个空列表使用的是 <code>class list([iterable])</code> 的类型构造器，参数可以是一个<code>iterable</code>，如果没有给出参数，构造器将创建一个空列表 <code>[]</code>，相比较而言多了一步 <code>class</code> 调用和参数判断，所以用 <code>[]</code> 直接构造一个空列表的方法速度更快。</p><p><strong>简而言之，主要的区别在于 <code>list()</code> 是一个 function call，Python 的 function call 会创建 stack，并且进行一系列参数检查的操作，中间的开销相对而言就更大了，而 <code>[]</code> 是一个内置的 C 函数，可以直接被调用，因此效率高。</strong></p><p>PS：字典（dict）、元组（tuple）等的创建也是如此。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们想创建一个空列表，可以使用如下两种方式：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# option A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;empty_list = list()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# option B&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;empty_list = []&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但你有没有想过它们之间在效率上会不会有什么不同呢？我们应该优先使用哪种方式呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lovemma.github.io/categories/Python/"/>
    
    
      <category term="内部探究" scheme="https://lovemma.github.io/tags/%E5%86%85%E9%83%A8%E6%8E%A2%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>Huey 每日定时任务的坑</title>
    <link href="https://lovemma.github.io/2019/05/16/Huey-%E6%AF%8F%E6%97%A5%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%9D%91/"/>
    <id>https://lovemma.github.io/2019/05/16/Huey-每日定时任务的坑/</id>
    <published>2019-05-16T07:40:59.000Z</published>
    <updated>2019-05-16T08:00:55.649Z</updated>
    
    <content type="html"><![CDATA[<p>最近别人推荐了个轻量级任务队列 Huey，然后我就去试了下，挺好用的，但却碰了文档未说明的坑。</p><a id="more"></a><p>我要做一个每日执行一次的任务，文档只给出每三分钟执行一次的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> huey <span class="keyword">import</span> SqliteHuey</span><br><span class="line"><span class="keyword">from</span> huey <span class="keyword">import</span> crontab</span><br><span class="line"></span><br><span class="line">huey = SqliteHuey(filename=<span class="string">'/tmp/demo.db'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@huey.periodic_task(crontab(minute='*/3'))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">every_three_minutes</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'This task runs every three minutes'</span>)</span><br></pre></td></tr></table></figure><p>我以为每日执行一次可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@huey.periodic_task(crontab(day='*/1'))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_in_a_day</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-- PERIODIC TASK -- THIS RUNS EVERY 1 DAYS --'</span>)</span><br></pre></td></tr></table></figure><p>结果它每一分钟就执行了一次，我：？？？</p><p>最后发现还需要设置执行小时和分钟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@huey.periodic_task(crontab(day='*/1', hour='0', minute='0'))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_in_a_day</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-- PERIODIC TASK -- THIS RUNS EVERY 1 DAYS --'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近别人推荐了个轻量级任务队列 Huey，然后我就去试了下，挺好用的，但却碰了文档未说明的坑。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lovemma.github.io/categories/Python/"/>
    
    
      <category term="Huey" scheme="https://lovemma.github.io/tags/Huey/"/>
    
  </entry>
  
  <entry>
    <title>Flask 的 Context 机制</title>
    <link href="https://lovemma.github.io/2019/03/25/Flask-%E7%9A%84-Context-%E6%9C%BA%E5%88%B6/"/>
    <id>https://lovemma.github.io/2019/03/25/Flask-的-Context-机制/</id>
    <published>2019-03-25T07:10:38.000Z</published>
    <updated>2019-03-30T03:34:46.586Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>一文带你全面理解 Flask 的 Context 机制。</p></blockquote><a id="more"></a><p>使用过 Flask 进行 Web 开发的同学应该知道 App Context 和 Request Context 这两个非常有特色的设计。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p><p>从一个 Flask App 读入配置并启动开始, 就进入了 App Context, 在其中我们可以访问配置文件、打开资源文件、通过路由规则反向构造 URL。当一个请求进入开始被处理时, 就进入了 Request Context, 在其中我们可以访问请求携带的信息, 比如 HTTP Method、表单域等。</p><p>最近闲着没什么事做, 研究了一番这两个 Context 的具体实现, 同时还解决了一些自己之前“知道结论不知道过程”的疑惑, 所以撰写本文记录下来。</p><h2 id="Thread-Local-的概念"><a href="#Thread-Local-的概念" class="headerlink" title="Thread Local 的概念"></a>Thread Local 的概念</h2><p>在面向对象的设计中, 对象是保存”状态”的地方。Python 也是如此, 一个对象的状态都被保存在对象携带的一个特殊字典(__dict__)中, 可以通过<code>vars</code>函数拿到它。</p><p>Thread Local 则是一种特殊的对象, 它的”状态”对线程隔离——也就是说每个线程对 Thread Local 对象的修改都不会影响到其他线程。这种对象的实现原理也非常简单, 只要以线程的 ID 来保存多份状态字典即可, 就像按照门牌号隔开的信箱。</p><p>在 Python 中获得一个这样的 Thread Local 最简单的方法是<code>threading.local</code>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">storage = threading.local()</span><br><span class="line">storage.foo = <span class="number">1</span></span><br><span class="line">print(storage.foo)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        storage.foo = <span class="number">2</span></span><br><span class="line">        <span class="comment"># storage.foo 在这个线程中已经发生改变</span></span><br><span class="line">        print(storage.foo)</span><br><span class="line"></span><br><span class="line">another = AnotherThread()</span><br><span class="line">another.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是在主线程里并没有改变</span></span><br><span class="line">print(storage.foo)</span><br></pre></td></tr></table></figure></p><p>这样来说, 只要能构造出 Thread Local 对象, 就能够让同一个对象在多个线程下做到状态隔离。这个”线程”不一定要是系统线程, 也可以是用户代码中的其他调度单元, 例如 Greenlet。</p><h2 id="Werkzeug-实现的-Local-Stack-和-Local-Proxy"><a href="#Werkzeug-实现的-Local-Stack-和-Local-Proxy" class="headerlink" title="Werkzeug 实现的 Local Stack 和 Local Proxy"></a>Werkzeug 实现的 Local Stack 和 Local Proxy</h2><p>Werkzeug 没有直接使用<code>threading.local</code>, 而是自己实现了<code>werkzeug.local.Local</code>类。后者和前者有一些区别:</p><ol><li>Werkzeug 实现的 Local 类会在 Greenlet 可用的情况下优先使用 Greenlet 的 ID 而不是线程 ID 以支持 Gevent 或者 Eventlet 的调度, 而<code>threading.local</code>只支持多线程调度;</li><li>Werkzeug 的 Local 类实现了 Werkzeug 自定义的协议方法<code>__release_local__</code>, 可以被 Werkzeug 自己的<code>release_local</code>函数释放掉当前线程下的状态, 而<code>threading.local</code>没有这个能力。</li></ol><p>除 Local 外, Werkzeug 还实现了两种数据结构：LocalStack 和 LocalProxy。</p><p>LocalStack 是用 Local 实现的栈结构, 可以将对象推入、弹出, 也可以快速拿到栈顶对象。当然, 所有的修改都只在本线程可见。和 Local 一样, LocalStack 也同样实现了支持 release_local 的接口。</p><p>LocalProxy 则是一个典型的代理模式实现, 它在构造时接受一个 callable 的参数（比如一个函数）, 这个参数被调用后的返回值本身应该是一个 Thread Local 对象。对一个 LocalProxy 对象的所有操作, 包括属性访问、方法调用（当然方法调用就是属性访问）甚至是二元操作都会转发到那个 callable 参数返回的 Thread Local 对象上。</p><p>LocalProxy 的一个使用场景是 LocalStack 的<code>__call__</code>方法。例如, <code>my_local_stack</code>是一个 LocalStack 实例, 那么调用<code>my_local_stack()</code>会返回一个 LocalProxy 对象, 这个对象始终指向<code>my_local_stack</code>的栈顶元素。如果栈顶元素不存在, 访问这个 LocalProxy 对象会抛出<code>RuntimeError</code>。</p><h2 id="Flask-基于-LocalStack-的-Context"><a href="#Flask-基于-LocalStack-的-Context" class="headerlink" title="Flask 基于 LocalStack 的 Context"></a>Flask 基于 LocalStack 的 Context</h2><p>Flask 是一个基于 Werkzeug 实现的框架, 所以 Flask 的 App Context 和 Request Context 也理所当然地基于 Werkzeug 的 Local Stack 实现。</p><p>在概念上, App Context 代表了”应用级别的上下文”, 比如配置文件中数据库的连接信息; Request Context 代表了”请求级别的上下文”, 比如当前访问的 URL。</p><p>这两个上下文对象的类定义在<code>flask.ctx</code>中, 它们的用法是将应用上下文和请求上下文推入推出到<code>flask.globals</code>中创建的<code>_app_ctx_stack</code>和<code>_request_ctx_stack</code>这两个 LocalStack 单例中。</p><p>因为 LocalStack 的状态是线程隔离的, 而 Web 应用中每个线程(或者 Greenlet)同时只能处理一个请求, 所以 App Context 对象和 Request Context 对象在请求中也是隔离的。</p><p>当<code>app = Flask(__name__)</code>构造出一个 Flask App 时, App Context 并不会自动被推入 Stack 中。所以此时 Local Stack 的栈顶是空的, <code>current_app</code>也是 unbound 状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> flask.globals <span class="keyword">import</span> _app_ctx_stack, _request_ctx_stack</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>app = Flask(__name__)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_app_ctx_stack.top</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_request_ctx_stack.top</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_app_ctx_stack()</span><br><span class="line">&lt;LocalProxy unbound&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> flask <span class="keyword">import</span> current_app</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>current_app</span><br><span class="line">&lt;LocalProxy unbound&gt;</span><br></pre></td></tr></table></figure><p>这也是 Flask 的一些使用者可能被坑的地方——比如编写一个离线脚本时, 如果直接在一个 Flask-SQLAlchemy 写成的 Model 上调用<code>User.query.get(user_id)</code>, 就会遇到<code>RuntimeError</code>。因为此时 App Context 还没被推入栈中, 而 Flask-SQLAlchemy 需要数据库连接信息时, 就会去<code>current_app.config</code>中获取, <code>current_app</code>指向的却是<code>_app_ctx_stack</code>为空的栈顶。</p><p>解决办法是运行脚本之前, 先将 App 的 App Context 推入栈中, 栈顶不为空后, <code>current_app</code>这个 LocalProxy 对象自然能将”取 config 属性”这个动作转发到当前的 App 上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ctx = app.app_context()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ctx.push()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_app_ctx_stack.top</span><br><span class="line">&lt;flask.ctx.AppContext object at <span class="number">0x102eac7d0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_app_ctx_stack.top <span class="keyword">is</span> ctx</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>current_app</span><br><span class="line">&lt;Flask <span class="string">'__main__'</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ctx.pop()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_app_ctx_stack.top</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>current_app</span><br><span class="line">&lt;LocalProxy unbound&gt;</span><br></pre></td></tr></table></figure><p>那么为什么在应用运行时不需要手动调用<code>app_context().push()</code>呢? 因为 Flask App 作为 WSGI Application 运行时, 会在每个请求进入的时候将请求上下文推入<code>_app_ctx_stack</code>中, 而请求上下文一定是在应用上下文中的, 所以推入部分的逻辑有这样一条: 如果发现<code>_app_ctx_stack</code>为空, 则隐式的推入一个 App 上下文。</p><p>所以, 请求中是不需要手动推上下文入栈的, 但是离线脚本需要手动推入上下文。</p><h2 id="两个疑问"><a href="#两个疑问" class="headerlink" title="两个疑问"></a>两个疑问</h2><p>这里还有两个疑问需要处理:</p><ul><li>为什么 App Context 需要独立出来: 既然在 Web 应用运行时, App Context 和 Request Context 都是 Thread Local 对象, 那么为什么还要独立区分二者呢?</li><li>为什么要放在”栈”里: 在 Web 应用运行时, 一个线程同时只能处理一个请求, 那么<code>_app_ctx_stack</code>和<code>_request_ctx_stack</code>栈顶肯定只有一个元素, 为什么还要用栈这种结构呢?</li></ul><p>这两个做法给予我们<strong>多个 Flask App 共存</strong>和<strong>非 Web 应用运行时灵活控制 Context</strong> 的可能性。</p><p>在对一个 Flask App 调用<code>app.run()</code>之后, 进程就进入阻塞模式并开始监听请求。此时是不可能让另一个 Flask App 在主线程运行起来的, 那么还有哪些场景需要多个 Flask App 共存呢?</p><p>之前说过 Flask App 实例就是一个 WSGI Application, 而 WSGI Middleware 是允许使用组合模式的, 比如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.wsgi <span class="keyword">import</span> DispatcherMiddleware</span><br><span class="line"><span class="keyword">from</span> your_application <span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">from</span> your_application.admin <span class="keyword">import</span> app <span class="keyword">as</span> admin_app</span><br><span class="line"></span><br><span class="line">application = DispatcherMiddleware(app, &#123;<span class="string">'/admin'</span>: admin_app&#125;)</span><br></pre></td></tr></table></figure></p><p>这个例子就是使用 Werkzeug 内置的 Middleware 将两个 Flask App 组合成一个 WSGI Application。这种情况下两个 App 都同时在运行, 只是根据请求 URL 的不同将请求分发到不同的 App 上进行处理。</p><blockquote><p>需要注意的是, 这种用法和 Flask 的 Blueprint 是有区别的。Blueprint 虽然和这种用法很类似, 但 Blueprint 自己是没有 App Context 的, 只是同一个 Flask App 内部资源共享的一种方式, 所以多个 Blueprint 共享了同一个 Flask App; 而使用 Middleware 面向的是所有的 WSGI Application, 不仅仅是 Flask App, 即使是把 Django App 和 Flask App 用这种方式组合起来也是可行的。</p></blockquote><h2 id="在非-Web-环境运行-Flask-关联的代码"><a href="#在非-Web-环境运行-Flask-关联的代码" class="headerlink" title="在非 Web 环境运行 Flask 关联的代码"></a>在非 Web 环境运行 Flask 关联的代码</h2><p>设想, 一个离线脚本需要操作两个甚至多个 Flask App 关联的上下文, 应该怎么办呢? 这时候栈结构的 App Context 的优势就展现出来了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> your_application <span class="keyword">import</span> create_app</span><br><span class="line"><span class="keyword">from</span> your_application.admin <span class="keyword">import</span> create_app <span class="keyword">as</span> create_admin_app</span><br><span class="line"></span><br><span class="line">app = create_app()</span><br><span class="line">admin_app = create_admin_app()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> app.app_context():</span><br><span class="line">        data = read_data()</span><br><span class="line">        <span class="keyword">with</span> admin_app.app_context():</span><br><span class="line">            write_data(data)</span><br><span class="line">        mark_data_copied()</span><br></pre></td></tr></table></figure></p><p>无论有多少个 App, 只要主动去 push 它的 App Context, Context Stack 中就会累计起来。这样, 栈顶永远是当前操作的 App Context, 当一个 App Context 结束的时候, 相应的栈顶元素也随之出栈。如果在执行过程中抛出了异常, 对应的 App Context 中注册的<code>teardown</code>函数被传入带有异常信息的参数。</p><p>这么一来就解释了之前的两个疑问——在这种单线程运行环境中, 只有栈结构才能保存多个 Context 并在其中定位出哪个才是”当前”。而离线脚本只需要 App 关联的上下文, 不需要构造出请求, 所以 App Context 也应该和 Request Context 分离。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Flask 的官方文档也对 <span class="exturl" data-url="aHR0cDovL2ZsYXNrLnBvY29vLm9yZy9kb2NzLzEuMC9hcHBjb250ZXh0Lw==" title="http://flask.pocoo.org/docs/1.0/appcontext/">App Context<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cDovL2ZsYXNrLnBvY29vLm9yZy9kb2NzLzEuMC9yZXFjb250ZXh0Lw==" title="http://flask.pocoo.org/docs/1.0/reqcontext/">Request Context<i class="fa fa-external-link"></i></span> 作出了详细的解释。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;一文带你全面理解 Flask 的 Context 机制。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lovemma.github.io/categories/Python/"/>
    
    
      <category term="Flask" scheme="https://lovemma.github.io/tags/Flask/"/>
    
      <category term="Python" scheme="https://lovemma.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>帮助理解encode和decode的小技巧</title>
    <link href="https://lovemma.github.io/2018/11/29/%E5%B8%AE%E5%8A%A9%E7%90%86%E8%A7%A3encode%E5%92%8Cdecode%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://lovemma.github.io/2018/11/29/帮助理解encode和decode的小技巧/</id>
    <published>2018-11-29T06:29:40.000Z</published>
    <updated>2018-11-29T06:30:16.051Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司业务需要做网络数据包处理，总是被字符的编码和解码折磨，一直以来我也不怎么搞得清楚什么时候该用<code>.encode()</code>, 什么时候该用<code>.decode()</code>。</p><p>现在发现了一个简单的方法，可帮助自己记住<code>.encode()</code>和<code>.decode()</code>的区别: 可以把字节序列想成晦涩难懂的机器码，把 Unicode 字符想象成“人类可读”的文本，那么，把字节序列变成人类可读的文本字符串就是<strong>解码</strong>，而把字符串变成用于存储或传输的字节序列就是<strong>编码</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近公司业务需要做网络数据包处理，总是被字符的编码和解码折磨，一直以来我也不怎么搞得清楚什么时候该用&lt;code&gt;.encode()&lt;/code&gt;, 什么时候该用&lt;code&gt;.decode()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;现在发现了一个简单的方法，可帮助自己记住&lt;code&gt;
      
    
    </summary>
    
      <category term="Python" scheme="https://lovemma.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lovemma.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python函数传参问题</title>
    <link href="https://lovemma.github.io/2018/11/28/Python%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/"/>
    <id>https://lovemma.github.io/2018/11/28/Python函数传参问题/</id>
    <published>2018-11-28T15:15:54.000Z</published>
    <updated>2018-12-04T06:14:46.205Z</updated>
    
    <content type="html"><![CDATA[<p>Python 唯一支持的参数传递模式是<strong>共享传参(call for sharing)</strong>。共享传参是指函数的各个形式参数获得实参中各个引用的副本，也就是说，函数内部的形参是实参的别名。</p><p>这种方案的结果是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标示(即不能把一个对象替换成另一个对象)。示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b)</span>:</span></span><br><span class="line">   ...:     a += b</span><br><span class="line">   ...:     <span class="keyword">return</span> a</span><br><span class="line">   ...: </span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: y = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: f(x, y)</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: x, y</span><br><span class="line">Out[<span class="number">5</span>]: (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: f(a, b)</span><br><span class="line">Out[<span class="number">8</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: a, b</span><br><span class="line">Out[<span class="number">9</span>]: ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: t = (<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: u = (<span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: f(t, u)</span><br><span class="line">Out[<span class="number">12</span>]: (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: t, u</span><br><span class="line">Out[<span class="number">13</span>]: ((<span class="number">10</span>, <span class="number">20</span>), (<span class="number">30</span>, <span class="number">40</span>))</span><br></pre></td></tr></table></figure><p>简单说明一下: 示例中是一个简单的函数，它在参数上调用<code>+=</code>运算符，分别把数字、列表和元组传给这个函数，实际传入的参数会以不同的方式受到影响。</p><a id="more"></a><h2 id="函数传参既不是传值也不是传引用"><a href="#函数传参既不是传值也不是传引用" class="headerlink" title="函数传参既不是传值也不是传引用"></a>函数传参既不是传值也不是传引用</h2><p>上面已经对函数给出了结论，这里来对<strong>共享传参考</strong>进行具体说明。</p><p>对于函数传参的问题，基本上有三种观点:</p><ol><li>传引用</li><li>传值</li><li>可变对象传引用，不可变对象传值</li></ol><p>这三个观点到底哪个正确呢？我们逐一进行讨论。</p><h3 id="传引用"><a href="#传引用" class="headerlink" title="传引用"></a>传引用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">inc</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(id(n))</span><br><span class="line"><span class="meta">... </span>    n = n + <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    print(id(n))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(n)</span><br><span class="line"><span class="number">4418535520</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inc(n)</span><br><span class="line"><span class="number">4418535520</span> <span class="comment"># 修改之前的 n 的 id 值</span></span><br><span class="line"><span class="number">4418535552</span> <span class="comment"># 修改之后的 n 的 id 值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(n)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>按照传引用的概念，上面的例子输出应该是 4，并且 <code>inc()</code> 函数里面执行操作 <code>n = n + 1</code> 的前后 n 的 id 值应该是不变的。可是事实是不是这样的呢？</p><p>从输出的结果来看 n 的值还是不变，但 id(n) 的值在函数体前后却不一样。显然，传引用这个说法是不恰当的。</p><h3 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">change_list</span><span class="params">(orginator_list)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'orginator list is: '</span>, orginator_list)</span><br><span class="line"><span class="meta">... </span>    new_list = orginator_list</span><br><span class="line"><span class="meta">... </span>    new_list.append(<span class="string">'I am new item'</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'new list is: '</span>, new_list)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> new_list</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>orginator_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_list = change_list(orginator_list)</span><br><span class="line">orginator list <span class="keyword">is</span>:  [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">new list <span class="keyword">is</span>:  [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'I am new item'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>orginator_list</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'I am new item'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_list</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'I am new item'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>传值通俗来讲就是这个意思: 你在内存中有一个位置，我也有一个位置，我把我的值复制给你，以后你做什么就跟我没关系了，你我之间井水不犯河水。可是上面的程序输出根本不是这么一回事，显示<code>change_list()</code>函数没有遵守约定，调用该函数之后<code>orginator_list</code>也发生了改变，这明显侵犯了<code>orginator_list</code>的权利。这么看来传值这个说法也不合适。</p><h3 id="可变对象传引用，不可变对象传值。"><a href="#可变对象传引用，不可变对象传值。" class="headerlink" title="可变对象传引用，不可变对象传值。"></a>可变对象传引用，不可变对象传值。</h3><p>从上面的例子看来这个说法最靠谱，很多人也是这么理解的，但这个是否真的准确呢？再来看一个示例。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">change_me</span><span class="params">(org_list)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(id(org_list))</span><br><span class="line"><span class="meta">... </span>    new_list = org_list</span><br><span class="line"><span class="meta">... </span>    print(id(new_list))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> len(new_list) &gt; <span class="number">5</span>:</span><br><span class="line"><span class="meta">... </span>        new_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i, e <span class="keyword">in</span> enumerate(new_list):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> isinstance(e, list):</span><br><span class="line"><span class="meta">... </span>            new_list[i] = <span class="string">'***'</span> <span class="comment"># 将类型为 list 类型的元素替换为 ***</span></span><br><span class="line"><span class="meta">... </span>    print(new_list)</span><br><span class="line"><span class="meta">... </span>    print(id(new_list))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>传入的参数 org_list 为列表，属于可变类型，按照可变对象传引用的理解，new_list 和 org_list 指向同一块内存，因此两者的 id 值输出一致，任何对 new_list 所执行的内容的操作会直接反应到 org_list，也就是说修改 new_list 会导致 org_list 的直接修改，那么，接下来看看测试的例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>test1 = [<span class="number">1</span>, [<span class="string">'a'</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">1</span>], <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>change_me(test1)        <span class="comment"># test1 的元素个数小于 5</span></span><br><span class="line"><span class="number">4421003592</span></span><br><span class="line"><span class="number">4421003592</span></span><br><span class="line">[<span class="number">1</span>, <span class="string">'***'</span>, <span class="string">'***'</span>, <span class="number">6</span>]        <span class="comment"># test1 中所有 list 类型的元素都被替换成了 ***</span></span><br><span class="line"><span class="number">4421003592</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test1</span><br><span class="line">[<span class="number">1</span>, <span class="string">'***'</span>, <span class="string">'***'</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, [<span class="number">1</span>]] <span class="comment"># test2 中的元素个数大于 5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>change_me(test2)</span><br><span class="line"><span class="number">4420665416</span></span><br><span class="line"><span class="number">4420665416</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="number">4421780808</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test2       <span class="comment"># test2 并没有发生改变</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, [<span class="number">1</span>]]</span><br></pre></td></tr></table></figure></p><p>对于 test1、new_list 和 org_list 的表现和我们理解的传引用确实是一致的，最后 test1 被修改为 [1, ‘***‘, ‘***‘, 6]，但对于输入的 test2、new_list 和 org_list 的 id 输出在进行列表相关的操作前是一致的，但操作之后 new_list 的 id 却变为了 4421780808，整个 test2 在调用函数 change_me 后却没有发生任何改变，可是按照传引用的理解，期望的输出应该是 [‘a’, ‘b’, ‘c’]，似乎可变对象传引用这个说法也不恰当。</p><p>那么 Python 函数中参数传递的机制到底是怎么样的呢？要明白这个概念，首先要理解: <strong>Python 中的赋值与我们所理解的 C/C++ 等语言中的意思并不一样。</strong></p><p>如果有如下语句:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span>, b = a, b = <span class="number">7</span>;</span><br></pre></td></tr></table></figure></p><p>我们分别来看一下在 C/C++ 以及 Python 中是如何赋值的。<br><img src="http://note.youdao.com/yws/res/1525/908570FF77E94E79AD519DCA4AC6FEAF" alt="C/C++ 赋值时的内存变化"><br>如图所示，C/C++ 中当执行 b=a 的时候，在内存中申请一块内存并将 a 的值复制到该内存中；当执行 b=7 之后是将 b 对应的值从 5 修改为 7。</p><p>但在 Python 中赋值并不是复制，b=a 操作使得 b 与 a 引用同一个对象。而 b=7 则是将 b 指向对象 7，如下图所示:<br><img src="http://note.youdao.com/yws/res/1522/17ACE0CE4E704EB1B6ED1885A8E2D01B" alt="Python 中赋值语句对应的内存变化"></p><p>我们通过以下示例来验证上面所述的过程:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4418535584</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)   <span class="comment"># b = a 之后 b 的 id 值和 a 一样</span></span><br><span class="line"><span class="number">4418535584</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)   <span class="comment"># b = 7 之后，b 指向对象 7，id 值发生改变</span></span><br><span class="line"><span class="number">4418535648</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4418535584</span></span><br></pre></td></tr></table></figure></p><p>从输出可以看到，b = a 赋值后 b 的 id() 输出和 a 一样，但进行 b = 7 操作后，b 指向另外一快空间。可以简单的理解为，b = a 传递的是对象的引用，其过程类似于贴“标签”，5 和 7 是实实在在的内存空间，执行 a = 5 相当于申请一块内存空间代表对象 5，然后在上面贴上标签a，这样 a 和 5 便绑定到一起了。而 b = a 相当于对对象 5 再次贴上了标签 b，因此 a 和 b 实际都指向了 5。b = 7 操作之后，标签b重新贴到 7 所代表的对象上去了，而此时 5 仅有标签 a。</p><p>理解了上面的背景，再重新回过头来看前面的例子就很好理解了。对于传值的例子，n = n + 1，由于 n 为数字，是不可变对象，n + 1 会重新申请一块内存，并将变量 n 指向它。当调用完函数 inc(n) 之后，函数体中的局部变量在函数外并不可见，此时的 n 代表函数外面的命名空间中所对应的 n，值还是 3。而在“可变对象传引用，不可变对象传值”的例子中，当 org_list 的长度大于 5 的时候，new_list = [‘a’, ‘b’, ‘c’] 操作重新创建了一块内存并将 new_list 指向它。当传入参数为 test2 = [1, 2, 3, 4, 5, 6, [1]] 的时候，函数的执行并没有改变该列表的值。</p><p>因此，对于 Python 函数参数传递的是值还是引用的问题的答案是: 都不是。正确的叫法应该是<strong>传对象</strong>或者说<strong>传对象的引用</strong>。函数参数在传递过程中将整个对象传入，对可变对象的修改在函数外部以及内部都可见，调用者和被调用者之间共享这个对象；而对于不可变对象，由于并不能真正的被修改，一次，修改往往是通过生成一个新的对象然后赋值来实现的。</p><h2 id="不要使用可变类型作为参数的默认值"><a href="#不要使用可变类型作为参数的默认值" class="headerlink" title="不要使用可变类型作为参数的默认值"></a>不要使用可变类型作为参数的默认值</h2><p>可选参数可以有默认值，这是 Python 函数定义的一个很棒的特性，这样我们的 API 在进化的同时能保证向后兼容，然而，我们应该避免使用可变的对象作为参数的默认值。示例如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HauntedBus</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=[])</span>:</span></span><br><span class="line">        self.passengers = passengers</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.append(name)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.remove(name)</span><br><span class="line">        </span><br><span class="line">运行结果:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1 = HauntedBus([<span class="string">'Alice'</span>, <span class="string">'Bill'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers</span><br><span class="line">[<span class="string">'Alice'</span>, <span class="string">'Bill'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.pick(<span class="string">'Charlie'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1,drop(<span class="string">'Alice'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers</span><br><span class="line">[<span class="string">'Bill'</span>, <span class="string">'Charlie'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2 = HauntedBus()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.pick(<span class="string">'Carrie'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span><br><span class="line">[<span class="string">'Carrie'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3 = HauntedBus()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers</span><br><span class="line">[<span class="string">'Carrie'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.pick(<span class="string">'Dave'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span><br><span class="line">[<span class="string">'Carrie'</span>, <span class="string">'Dave'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers <span class="keyword">is</span> bus3.passengers</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers</span><br><span class="line">[<span class="string">'Bill'</span>, <span class="string">'Charlie'</span>]</span><br></pre></td></tr></table></figure></p><p>这是因为 self.pasengers 变成了 passengers 参数默认值的别名，出现这个问题的根源是: 默认值在定义函数时计算（通常是加载模块时)，因此默认值变成了函数对象对象的属性。因此，如果默认值是可变对象，而且修改了它的值，那么后续的函数调用都会受到影响。</p><p>在运行完上面的代码后，可以审查 <code>HauntedBus.__init__</code> 对象，看看它的<code>__defaults__</code>属性中的那些值:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(HauntedBus.__init__)</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, ... ]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>HauntedBus.__init__.__defaults__</span><br><span class="line">([<span class="string">'Carrie'</span>, <span class="string">'Dave'</span>],)</span><br></pre></td></tr></table></figure></p><p>最后，我们可以验证 bus2.passengers 是一个别名，它绑定到 <code>HauntedBus.__init__.__defaults__</code>属性的第一个元素上:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>HauntedBus.__init__.__defaults__[<span class="number">0</span>] <span class="keyword">is</span> bus2.passengers</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></p><p>可变默认值导致的这个问题说明了为什么通常使用 None 作为接受可变值的参数的默认值。如下所示:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.passengers = []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.passengers = list(passengers)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.append(name)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.remove(name)</span><br></pre></td></tr></table></figure></p><h2 id="防御可变参数"><a href="#防御可变参数" class="headerlink" title="防御可变参数"></a>防御可变参数</h2><p>如果定义的函数接受可变参数，应该谨慎考虑调用方是否期望修改传入的参数。</p><p>例如，如果函数接受一个字典，而且在处理的过程中要修改它，那么这个副作用要不要体现到函数外部？具体情况具体分析。这其实需要函数的编写者和调用方达成共识。</p><p>在下面这个示例中，TwilightBus 实例与客户共享乘客列表，这回产生意料之外的结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwilightBus</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.passengers = []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.passengers = passengers</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.append(name)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.remove(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">basketball_team = [<span class="string">'Sue'</span>, <span class="string">'Tina'</span>, <span class="string">'Maya'</span>, <span class="string">'Diana'</span>, <span class="string">'Pat'</span>]</span><br><span class="line">bus = TwilightBus(basketball_team)</span><br><span class="line">bus.drop(<span class="string">'Tina'</span>)</span><br><span class="line">bus.drop(<span class="string">'Pat'</span>)</span><br><span class="line"><span class="comment"># basketball_team的内容</span></span><br><span class="line">print(baskekball_team)</span><br><span class="line">out: [<span class="string">'Sue'</span>, <span class="string">'Maya'</span>, <span class="string">'Diana'</span>]</span><br></pre></td></tr></table></figure></p><p>TwilightBus 违反了设计接口的最佳实践，即“最少惊讶原则(Principle of least astonishment)”。篮球队员从校车中下车后，名字就从篮球队的名单中消失了，这确实让人惊讶。</p><p>这里的问题是，校车为传给构造方法的列表创建了别名。正确的做法是，校车自己维护乘客的列表，修正的方法很简单: 在<code>__init__</code>方法中，传入 passengers 参数时，应该把参数值的副本赋值给 self.passengers，如下所示:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.passengers = []</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.passengers = list(passengers)</span><br></pre></td></tr></table></figure></p><p>在内部像这样处理乘客列表，就不会影响初始化校车时传入的参数了。此外，这种处理方式还更灵活: 现在，传给 passengers 参数的值可以是元组或任何其他可选迭代对象，例如<code>set</code>对象，甚至数据库查询结果，因为<code>list</code>构造方法接受任何可迭代对象。自己创建并管理列表可以确保支持所需的<code>.remove()</code>和<code>.append()</code>操作，这样<code>.pick()</code>和<code>.drop()</code>方法才能正常运作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 唯一支持的参数传递模式是&lt;strong&gt;共享传参(call for sharing)&lt;/strong&gt;。共享传参是指函数的各个形式参数获得实参中各个引用的副本，也就是说，函数内部的形参是实参的别名。&lt;/p&gt;
&lt;p&gt;这种方案的结果是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标示(即不能把一个对象替换成另一个对象)。示例如下:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;In [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(a, b)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ...:     a += b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ...:     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ...: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]: x = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]: y = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]: f(x, y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Out[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]: x, y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Out[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]: (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;]: a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;]: b = [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;]: f(a, b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Out[&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;]: [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;]: a, b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Out[&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;]: ([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]: t = (&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;]: u = (&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;]: f(t, u)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Out[&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;]: (&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In [&lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;]: t, u&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Out[&lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;]: ((&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;简单说明一下: 示例中是一个简单的函数，它在参数上调用&lt;code&gt;+=&lt;/code&gt;运算符，分别把数字、列表和元组传给这个函数，实际传入的参数会以不同的方式受到影响。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lovemma.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lovemma.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>MySQL死锁检测中热点行更新导致的性能问题</title>
    <link href="https://lovemma.github.io/2018/11/28/MySQL%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%AD%E7%83%AD%E7%82%B9%E8%A1%8C%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/"/>
    <id>https://lovemma.github.io/2018/11/28/MySQL死锁检测中热点行更新导致的性能问题/</id>
    <published>2018-11-28T09:33:47.000Z</published>
    <updated>2018-11-28T09:34:25.273Z</updated>
    
    <content type="html"><![CDATA[<p>有一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。这个业务涉及到以下操作：</p><ol><li>从顾客 A 的账户余额中扣除电影票价；</li><li>给影院 B 的账户余额中增加这张电影的票价；</li><li>记录一条交易日志。</li></ol><p>也就是说，要完成这个交易，我们需要 update 两条记录，并 insert 一条记录。当然，为了保证交易的原子性，我们要把这三个操作一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？</p><p>试想如果同时有另一个顾客 C 要在影院 B 买票，那么这两个事务冲突的部分就是语句 2 了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。</p><p>根据两阶段锁协议，不论怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句 2 安排在最后，比如按照 3、1、2 这样的顺序执行，那么影院账户余额这一行的锁时间就最少。这样就最大程度地减少了事务之间的锁等待，提高了并发度。</p><p>如果这个影院做活动，可以低价预售一年之内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的 MySQL 就挂了。登上服务器一看，CPU 消耗接近 100%，但整个数据库每秒就只执行不到 100 个事务。这是什么原因呢？<br><a id="more"></a><br>这里就要说到死锁和死锁检测了。</p><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。示例如下:<br><img src="https://static001.geekbang.org/resource/image/4d/52/4d0eeec7b136371b79248a0aed005a52.jpg" alt></p><p>事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。</p><p>当死锁出现后，有两种解决策略：</p><ol><li>直接进入等待状态，直到超时。这个超时的时间可以通过参数<code>innodb_lock_wait_timeout</code>来设置。</li><li>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数<code>innodb_deadlock_detect</code>设置为 on，表示开启这个逻辑。</li></ol><p>在 InnoDB 中，<code>innodb_lock_wait_timeout</code>的默认值是 50s，意味着如果采用第一个策略，当出现死锁后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p><p>但是，我们又不能直接把这个时间设置成一个很小的值，比如 1s，这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以超时时间设置的太短的话，会出现很多的误伤。</p><p>所以正常情况下，我们还是要采取第二种策略，即: 主动死锁检测，而且<code>innodb_deadlock_detect</code>参数的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是额外负担的。</p><p>可以想象以下这个过程: 每当出现一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p><p>这里就可以回到我们上面说的那个问题了。</p><p>每个新来的被堵住的线程，都要判断会不会由于自己的加入而导致了死锁，这是一个时间复杂度为 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此就会出现 CPU 利用率很高，但是每秒却执行不了几个事务。</p><p>根据上面的分析，我们该怎样解决这种热点行更新导致的性能问题呢? 问题的结症在与死锁检测要耗费大量的 CPU 资源。</p><ol><li>一种头疼医头、脚疼医脚的方法就是如果能确保这个业务一定不会出现死锁，可以临时把死锁检测给关掉。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当作一个严重的错误，毕竟出现了死锁，就回滚，然后通过业务重试，一般就没问题了，这是业务无损的，而关掉死锁检测意味着可能会出现大量的超时，这是有损的。</li><li>另一个思路是控制并发度。根据上面的分析，如果并发能够控制住，比如同一行同时最多只有 10 个线程在更新，那么进行死锁检测的成本很低，就不会出现这个问题。</li></ol><p>一个直接的想法就是在客户端做并发控制，但是这个方法不太可行，因为客户端很多，比如：一个应用有 600 个客户端，这样即使每个客户端控制到只有 5 个并发线程，汇总到数据库服务端以后，峰值并发数也可能会达到 3000。<br>​<br>因此，这个并发控制要实现在数据库服务端。如果有中间件，可以考虑在中间价中实现; 如果团队有能修改 MySQL 源码的人，也可以在 MySQL 里面实现。</p><p>基本思路就是: 对于相同行的更新，在进入引擎之前进行排队，这样在 InnoDB 内部就不会有大量的死锁检测工作了。</p><p>但是如果团队里暂时没有数据库方面的专家，不能实现这样的方案，可以考虑从设计上优化这个问题:</p><p>可以考虑通过将一行改成逻辑上的多行来减少锁冲突，以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 条记录的值的总和。每次要给影院账户加金额的时候，随机选其中一条记录来加，这样每次冲突的概率就变成原来的 1/10，可以减少锁等待的个数，也就减少了死锁检测的 CPU 消耗。</p><p>这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额减少，比如退票操作，这时候就需要考虑当一部分行记录变成 0 的时候，代码要有特殊的处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。这个业务涉及到以下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从顾客 A 的账户余额中扣除电影票价；&lt;/li&gt;
&lt;li&gt;给影院 B 的账户余额中增加这张电影的票价；&lt;/li&gt;
&lt;li&gt;记录一条交易日志。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是说，要完成这个交易，我们需要 update 两条记录，并 insert 一条记录。当然，为了保证交易的原子性，我们要把这三个操作一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？&lt;/p&gt;
&lt;p&gt;试想如果同时有另一个顾客 C 要在影院 B 买票，那么这两个事务冲突的部分就是语句 2 了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。&lt;/p&gt;
&lt;p&gt;根据两阶段锁协议，不论怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句 2 安排在最后，比如按照 3、1、2 这样的顺序执行，那么影院账户余额这一行的锁时间就最少。这样就最大程度地减少了事务之间的锁等待，提高了并发度。&lt;/p&gt;
&lt;p&gt;如果这个影院做活动，可以低价预售一年之内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的 MySQL 就挂了。登上服务器一看，CPU 消耗接近 100%，但整个数据库每秒就只执行不到 100 个事务。这是什么原因呢？&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://lovemma.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://lovemma.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>在mysql如何挑选索引列</title>
    <link href="https://lovemma.github.io/2018/11/27/%E5%9C%A8mysql%E5%A6%82%E4%BD%95%E6%8C%91%E9%80%89%E7%B4%A2%E5%BC%95%E5%88%97/"/>
    <id>https://lovemma.github.io/2018/11/27/在mysql如何挑选索引列/</id>
    <published>2018-11-27T06:54:52.000Z</published>
    <updated>2018-11-27T07:27:17.437Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><strong>为用于搜索、排序或分组的列创建索引，而对于用作输出显示的列则不用创建索引。</strong>这意味着最佳索引候选列是那些出现在 WHERE 子句中的列、连接子句中的列或者出现在 ORDER BY 或 GROUP BY 子句中的列。而那些只是出现在 SELECT 关键字后面的输出列表里的列，则不是很好的索引候选列。</p></li><li><p><strong>认真考虑数据列基数。</strong>列的基数(cardinality)是指它所容纳的所有非重复值的个数，例如，某个列包含值 1、3、7、4、7、3，那么它的基数为 4。相对于表里面行的总数来说，列的基数越高(也就就是说，它包含的唯一值多，重复值少)，索引的使用效果越好。对于包含许多不同年龄值的列，索引可以很容易地将各个行区分开来。但是对于记录性别的列，其中只会包含两个值：’M’和’F’，索引操作毫无用处。如果这两个值出现的频率大致一样，那么不管搜索哪个值，你得到的都是近乎一半的行。在这种情况下，索引可能根本无法使用，因为当查询优化程序确定出某个值在表的行里出现频率很大时，它会跳过索引，直接执行全表扫描操作。</p></li></ol><a id="more"></a><ol start="3"><li><p><strong>索引短小值。</strong>应该尽量选用较小的数据类型，较短小的值可以在一下几个方面提高索引的处理效率:</p><ul><li>短小值可以让比较操作更快，从而加快索引查找速度。</li><li>短小值可以让索引短小，从而减少对磁盘 I/O 请求。</li><li><p>对于短小的键值，键缓存里的索引块可以容纳更多的键值。如果 MySQL 能在内存里容纳更多的键，那么就可以在不从磁盘读取更多索引块的前提下，提高找到键值的几率。</p><blockquote><p>对 InnoDB 存储引擎，因为它使用的是聚簇索引（clustered index），所以让主键尽量短小会带来更多好处。聚簇索引会把数据行和主键值存储在一起(即聚集在一起)。其他的索引都是二级索引，即它们把主键值和二级索引值存储在一起。在二级索引里进行查找，会先得到主键值，然后再通过它在主键索引中定位到相应的行。ps: 该行为被称为回表操作。这意味着，主键值在每一个二级索引里都会重复出现，因此如果主键值较长，则会导致每一个二级索引需要占用更多的存储空间。</p></blockquote></li></ul></li><li><p><strong>索引字符串的前缀。</strong>想要对字符串列进行索引，应当尽可能指定前缀长度。例如，有一个 CHAR(20) 列，如果大多数值的前 10 或 20 个字符都是唯一的，那么就可以不用为整个进行索引，而只为前面的 10 或 20 个字符进行索引，这样可以节省大量的索引空间，而且还能使索引变得更快。不过，只索引列的第一个字符恐怕不行，因为这样做会导致索引无法获得大量的唯一值。</p></li><li><p><strong>利用最左前缀。</strong>当创建包含 n 个列的符合索引时，实际上会创建 n 个专供 MySQL 使用的索引。复合索引相当于多个索引，因为索引中最左边的任意数据列集合都可用于匹配各个行，这样的集合即为“最左前缀”。(这与对列的前缀进行索引有所不同，它会使用列值的前 n 个字符或字节来创建索引。)</p></li><li><p><strong>不要建立过多的索引。</strong>不要以为索引“越多越好”，然后就为你所能看到的所有数据列都建立索引，这是因为每增加一个索引都需要占据额外的磁盘空间，而且都会影响写入操作的性能。在对表做了修改之后，索引就会更新，并且可能还会重组，索引越多，整个过程所占用的时间就越长。很少使用或从不使用索引，会大大降低表的修改速度。此外，在为检索生成执行计划时，MySQL 会对索引进行仔细推敲，创建多余的索引，会为查询优化程序增加更多的工作，当表有太多的索引时，MySQL 还有可能(只是存在可能)无法使用最好的索引。</p></li><li><p><strong>让参与比较的索引类型保持匹配。</strong>在创建索引时，大部分存储存储引擎都会选择它们要使用的索引实现。例如，InnoDB 总会使用 B 树索引; MyISAM 也会使用 B 树索引，但对于空间类型则会改用 R 树索引; MEMORY 存储引擎默认会使用散列索引，但它也支持 B 树索引，并允许在这两者之间进行选择。</p><blockquote><p>在选择索引类型时，请考虑计划在索引列上执行的是什么类型的比较操作:</p><ul><li>对于散列索引，会有一个散列函数应用于每一个列值。最终的散列值都会被存入索引，用于执行查找。(散列函数的算法，会尽量为不同的输入值生成不同的散列值，使用散列值的好处是它们之间的比较比其原始值更有效率。) 在使用运算符<code>=</code>或<code>&lt;=&gt;</code>完成精度匹配的比较操作里，散列索引的速度非常快。但在那些用于查找一个范围内的值的比较操作里，它们却表现欠佳，如下列表达式:<pre><code class="sql">id &lt; 30或者weight BETWEEN 100 AND 150</code></pre></li><li>在使用<code>&lt;</code>、<code>&lt;=</code>、<code>=</code>、<code>&gt;=</code>、<code>&gt;</code>、<code>&lt;&gt;</code>、<code>!=</code>和<code>BETWEEN</code>运算符，进行精确比较或范围比较时，使用 B 树索引会带来高效。如果匹配模式是以一个纯字符串，而不是一个通配符作为开头的，那么 B 树索引还可用在使用运算符<code>LIKE</code>进行模式匹配的操作里。</li></ul></blockquote></li><li><p><strong>使用慢查询日志找出那些性能低劣的查询。</strong>这个日志可以帮助我们找出从索引当中获益的查询，慢查询日志是一个文本文件，它可以用任何文件显示程序打开查看，也可以用 mysqldumpslow 工具来汇总其内容。如果某个给定的查询在这个日志里频繁出现，那么这个查询可能就不是最优的，需要改写，以让它运行得更快。在查看慢查询日志时，请记住“慢”是实时测量出来的，因此，与处于低负载时相比，服务器处于高负载时，会往慢查询日志里写入更多的查询。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;为用于搜索、排序或分组的列创建索引，而对于用作输出显示的列则不用创建索引。&lt;/strong&gt;这意味着最佳索引候选列是那些出现在 WHERE 子句中的列、连接子句中的列或者出现在 ORDER BY 或 GROUP BY 子句中的列。而那些只是出现在 SELECT 关键字后面的输出列表里的列，则不是很好的索引候选列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;认真考虑数据列基数。&lt;/strong&gt;列的基数(cardinality)是指它所容纳的所有非重复值的个数，例如，某个列包含值 1、3、7、4、7、3，那么它的基数为 4。相对于表里面行的总数来说，列的基数越高(也就就是说，它包含的唯一值多，重复值少)，索引的使用效果越好。对于包含许多不同年龄值的列，索引可以很容易地将各个行区分开来。但是对于记录性别的列，其中只会包含两个值：’M’和’F’，索引操作毫无用处。如果这两个值出现的频率大致一样，那么不管搜索哪个值，你得到的都是近乎一半的行。在这种情况下，索引可能根本无法使用，因为当查询优化程序确定出某个值在表的行里出现频率很大时，它会跳过索引，直接执行全表扫描操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://lovemma.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://lovemma.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中不同存储引擎的索引的实现方式</title>
    <link href="https://lovemma.github.io/2018/11/25/MySQL%E4%B8%AD%E4%B8%8D%E5%90%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>https://lovemma.github.io/2018/11/25/MySQL中不同存储引擎的索引的实现方式/</id>
    <published>2018-11-25T08:34:17.000Z</published>
    <updated>2018-11-25T08:35:07.042Z</updated>
    
    <content type="html"><![CDATA[<p>对于不同的 MySQL 存储引擎，索引的具体实现细节也有所不同。</p><ol><li>对于 <strong>MyISAM</strong> 表，其数据行保存在数据文件中，而索引值则保存在索引文件里。一个表可以有多个索引，但它们都保存在同一个索引文件里。索引文件里的每一个索引都由一组有序的关键字行构成，这个组中的关键字行主要用于快速访问数据文件。</li><li><strong>InnoDB</strong> 存储引擎没有按照上面的方法将行和索引值分开放置，尽管它也是把索引值当作是一组有序值。默认情况下，<strong>InnoDB</strong> 存储引擎只使用一个表空间，在这个表空间的内部，管理着所有 <strong>InnoDB</strong> 表的数据存储和索引存储。可以通过配置 <strong>InnoDB</strong>，让它创建的每个表都有自己的表空间，但即使如此，给定表的数据和索引也同样保存在同一个表空间文件里。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于不同的 MySQL 存储引擎，索引的具体实现细节也有所不同。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于 &lt;strong&gt;MyISAM&lt;/strong&gt; 表，其数据行保存在数据文件中，而索引值则保存在索引文件里。一个表可以有多个索引，但它们都保存在同一个索引文件里。索引文件里的每一
      
    
    </summary>
    
      <category term="数据库" scheme="https://lovemma.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://lovemma.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>在数据库中为什么尽量不使用长事务?</title>
    <link href="https://lovemma.github.io/2018/11/20/%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%BD%E9%87%8F%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%95%BF%E4%BA%8B%E5%8A%A1/"/>
    <id>https://lovemma.github.io/2018/11/20/在数据库中为什么尽量不使用长事务/</id>
    <published>2018-11-20T05:59:30.000Z</published>
    <updated>2018-11-25T08:20:33.403Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这会导致大量的占用存储空间。</p><blockquote><p>在 MySQL 5.5 及以前的版本中，回滚日志跟数据字典一起放在 ibdata 文件里面，即使长事务最终提交，回滚段被清理，文件也不会变小。</p></blockquote></li><li><p>除了对回滚段有影响，长事务还占用锁资源，这也有可能会拖垮整个库。</p></li></ol><a id="more"></a><h2 id="如何避免长事务对业务的影响"><a href="#如何避免长事务对业务的影响" class="headerlink" title="如何避免长事务对业务的影响"></a>如何避免长事务对业务的影响</h2><p>这个问题，我们可以从应用开发端和数据库端分开来看。</p><h3 id="从应用端来看："><a href="#从应用端来看：" class="headerlink" title="从应用端来看："></a>从应用端来看：</h3><ol><li>确认是否使用了 set autocommit=0。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。</li><li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。但有些业务并没有这个需要，但也把好几个 select 语句放到事务中。这种只读事务可以去掉。</li><li>业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</li></ol><h3 id="从数据库端来看"><a href="#从数据库端来看" class="headerlink" title="从数据库端来看"></a>从数据库端来看</h3><ol><li>监控 information_schema.innodb_trx 表，设置长事务阀值，超过就报警或者 kill。</li><li>Percona 的 pt-kill 这个工具不错，推荐使用。</li><li>在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题。</li><li>如果使用的是 MySQL 5.6 或者更高的版本，把 innodb_undo_tablespaces 设置成 2 (或者更大的值)。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这会导致大量的占用存储空间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 MySQL 5.5 及以前的版本中，回滚日志跟数据字典一起放在 ibdata 文件里面，即使长事务最终提交，回滚段被清理，文件也不会变小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;除了对回滚段有影响，长事务还占用锁资源，这也有可能会拖垮整个库。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://lovemma.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://lovemma.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>模板模式</title>
    <link href="https://lovemma.github.io/2018/10/31/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lovemma.github.io/2018/10/31/模板模式/</id>
    <published>2018-10-31T05:58:04.000Z</published>
    <updated>2018-10-31T06:37:54.401Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>模板模式：抽象出算法公共部分从而实现代码复用。</p></blockquote><p>编写优秀代码的一个要素是避免冗余。在面向对象编程中，方法和函数是我们用来避免编写冗余代码的重要工具。</p><p>模板设计模式旨在消除代码重复。如果我们发现结构相近的（多个）算法中有重复代码，则可以把算法的不变（通用）部分留在一个模板方法/函数中，把易变（不同）的部分移到动作/钩子方法/函数中。</p><a id="more"></a><p>实际上这种模式在代码重构的时候是经常使用的 ，这里以一个例子来进行说明:</p><p>首先安装<code>cowpy</code>(ps: 竟然有人编写这个)：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install cowpy</span><br></pre></td></tr></table></figure></p><p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cowpy <span class="keyword">import</span> cow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dots_style</span><span class="params">(msg)</span>:</span></span><br><span class="line">    msg = msg.capitalize()</span><br><span class="line">    msg = <span class="string">'.'</span> * <span class="number">10</span> + msg + <span class="string">'.'</span> * <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">admire_style</span><span class="params">(msg)</span>:</span></span><br><span class="line">    msg = msg.upper()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'!'</span>.join(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cow_style</span><span class="params">(msg)</span>:</span></span><br><span class="line">    msg = cow.milk_random_cow(msg)</span><br><span class="line">    <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_banner</span><span class="params">(msg, style=dots_style)</span>:</span></span><br><span class="line">    print(<span class="string">'-- start of banner --'</span>)</span><br><span class="line">    print(style(msg))</span><br><span class="line">    print(<span class="string">'-- end of banner --\n\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    msg = <span class="string">'happy coding'</span></span><br><span class="line">    [generate_banner(msg, style) <span class="keyword">for</span> style <span class="keyword">in</span> (dots_style, admire_style,</span><br><span class="line">                                            cow_style)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- start of banner --</span><br><span class="line">..........Happy coding..........</span><br><span class="line">-- end of banner --</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- start of banner --</span><br><span class="line">H!A!P!P!Y! !C!O!D!I!N!G</span><br><span class="line">-- end of banner --</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- start of banner --</span><br><span class="line">______________</span><br><span class="line">&lt; happy coding &gt;</span><br><span class="line">--------------</span><br><span class="line">    o</span><br><span class="line">    o</span><br><span class="line">    ^__^         /</span><br><span class="line">    (**)\_______/  _________</span><br><span class="line">    (__)\       )=(  ____|_ \_____</span><br><span class="line">U    ||----w |  \ \     \_____ |</span><br><span class="line">        ||     ||   ||           ||</span><br><span class="line">-- end of banner --</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;模板模式：抽象出算法公共部分从而实现代码复用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编写优秀代码的一个要素是避免冗余。在面向对象编程中，方法和函数是我们用来避免编写冗余代码的重要工具。&lt;/p&gt;
&lt;p&gt;模板设计模式旨在消除代码重复。如果我们发现结构相近的（多个）算法中有重复代码，则可以把算法的不变（通用）部分留在一个模板方法/函数中，把易变（不同）的部分移到动作/钩子方法/函数中。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://lovemma.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Python" scheme="https://lovemma.github.io/tags/Python/"/>
    
      <category term="设计模式" scheme="https://lovemma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="https://lovemma.github.io/2018/10/31/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lovemma.github.io/2018/10/31/策略模式/</id>
    <published>2018-10-31T02:42:27.000Z</published>
    <updated>2018-10-31T02:43:04.105Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式是一种非常通用的设计模式，可应用的场景很多。一般来说，不论何时希望动态、透明地应用不同算法，策略模式都是可行之路。这里所说不同算法的意思是，目的相同但实现方案不同的一类算法。这意味着算法结果应该是完全一致的，但每种实现都有不同的性能和代码复杂性（举例来说，对比一下顺序查找和二分查找）。</p><p>策略模式的另一个应用是创建不同的样式表现，为了实现可移植性（例如，不同平台之间断行的不同）或动态地改变数据的表现。</p><p>另一个值得一提的应用是模拟；例如模拟机器人，一些机器人比另一些更有攻击性，一些机器人速度更快，等等。机器人行为中的所有不同之处都可以使用不同的策略来建模。</p><a id="more"></a><p>以排序算法为例子，挑选一个合适的排序算法的时候，需要考虑待排序数组的以下特征：</p><ul><li>需要排序的元素数量。大部分排序算法在输入规模很小的时候效率相差不大，只有一部分O(nlogn)平均时间复杂度的算法适合大规模排序。</li><li>算法的最佳/平均/最差时间复杂度。这个往往是挑选排序算法时候优先考虑的。</li><li>算法的空间复杂度。是不是原地排序(inplace)，需要额外的空间吗？在内存限制苛刻的时候就需要考虑。</li><li>算法的稳定性。排序算法是稳定的吗？稳定是指相同大小的值排序后保持相对顺序。</li><li>实现复杂度。算法是否容易实现，其他大致相同的情况下，优先考虑易维护的代码。</li></ul><p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(seq) &gt;= threshold_value:    <span class="comment"># 大于某个阈值</span></span><br><span class="line">        f1(seq)    <span class="comment"># 在数量较多时候具有良好的效率</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        f2(seq)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;策略模式是一种非常通用的设计模式，可应用的场景很多。一般来说，不论何时希望动态、透明地应用不同算法，策略模式都是可行之路。这里所说不同算法的意思是，目的相同但实现方案不同的一类算法。这意味着算法结果应该是完全一致的，但每种实现都有不同的性能和代码复杂性（举例来说，对比一下顺序查找和二分查找）。&lt;/p&gt;
&lt;p&gt;策略模式的另一个应用是创建不同的样式表现，为了实现可移植性（例如，不同平台之间断行的不同）或动态地改变数据的表现。&lt;/p&gt;
&lt;p&gt;另一个值得一提的应用是模拟；例如模拟机器人，一些机器人比另一些更有攻击性，一些机器人速度更快，等等。机器人行为中的所有不同之处都可以使用不同的策略来建模。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://lovemma.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Python" scheme="https://lovemma.github.io/tags/Python/"/>
    
      <category term="设计模式" scheme="https://lovemma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>状态模式</title>
    <link href="https://lovemma.github.io/2018/10/30/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lovemma.github.io/2018/10/30/状态模式/</id>
    <published>2018-10-30T13:18:49.000Z</published>
    <updated>2018-10-30T13:19:28.463Z</updated>
    
    <content type="html"><![CDATA[<p>状态模式是一个或多个有限状态机（简称状态机）的实现，用于解决一个特定的软件工程问题。</p><p>状态机是一个抽象机器，具有两个主要部分：状态和转换。状态是指一个系统的当前状况。一个状态机在任意时间点只会有一个激活状态。转换是指从当前状态到一个新状态的切换。在一个转换发生之前或之后通常会执行一个或多个动作。状态机可以使用状态图进行视觉上的展现。</p><p>状态机用于解决许多计算机问题和非计算机问题，其中包括交通灯、停车计时器、硬件设计和编程语言解析等。</p><a id="more"></a><p>这里以一个计算机系统的进程实现状态机为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先装下pip3 install state_machine</span></span><br><span class="line"><span class="keyword">from</span> state_machine <span class="keyword">import</span> (</span><br><span class="line">    acts_as_state_machine, State, Event, before, after, InvalidStateTransition</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@acts_as_state_machine</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Process</span>:</span></span><br><span class="line">    <span class="comment"># 先来定义状态机的状态 states</span></span><br><span class="line">    created = State(initial=<span class="literal">True</span>)    <span class="comment"># 初始状态</span></span><br><span class="line">    waiting = State()</span><br><span class="line">    running = State()</span><br><span class="line">    terminated = State()</span><br><span class="line">    blocked = State()</span><br><span class="line">    swapped_out_waiting = State()</span><br><span class="line">    swapped_out_blocked = State()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 再定义状态机的转移 transitions</span></span><br><span class="line">    wait = Event(from_states=(created, running, blocked,</span><br><span class="line">                            swapped_out_waiting), to_state=waiting)</span><br><span class="line">    run = Event(from_states=waiting, to_state=running)</span><br><span class="line">    terminate = Event(from_states=running, to_state=terminated)</span><br><span class="line">    block = Event(from_states=(running, swapped_out_blocked),</span><br><span class="line">                to_state=blocked)</span><br><span class="line">    swap_wait = Event(from_states=waiting, to_state=swapped_out_waiting)</span><br><span class="line">    swap_block = Event(from_states=blocked, to_state=swapped_out_blocked)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The state_machine module provides us with the @before and @after</span></span><br><span class="line">    <span class="comment"># decorators that can be used to execute actions before or after a</span></span><br><span class="line">    <span class="comment"># transition occurs, respectfully.</span></span><br><span class="line"><span class="meta">    @after('wait')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait_info</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&#123;&#125; entered waiting mode'</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @after('run')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_info</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&#123;&#125; is running'</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @before('terminate')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">terminate_info</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&#123;&#125; terminated'</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @after('block')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">block_info</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&#123;&#125; is blocked'</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @after('swap_wait')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swap_wait_info</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&#123;&#125; is swapped out and waiting'</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @after('swap_block')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swap_block_info</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&#123;&#125; is swapped out and blocked'</span>.format(self.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transition</span><span class="params">(process, event, event_name)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        process (Process obj):</span></span><br><span class="line"><span class="string">        event (Event obj): wait, run, terminate...</span></span><br><span class="line"><span class="string">        event_name (str): name of event</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        event()</span><br><span class="line">    <span class="keyword">except</span> InvalidStateTransition:</span><br><span class="line">        print(<span class="string">'Error: transition of &#123;&#125; from &#123;&#125; to &#123;&#125; failed'</span>.format(</span><br><span class="line">            process.name, process.current_state, event_name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">state_info</span><span class="params">(process)</span>:</span></span><br><span class="line">    <span class="string">""" 当前状态机的状态 """</span></span><br><span class="line">    print(<span class="string">'state of &#123;&#125;: &#123;&#125;'</span>.format(process.name, process.current_state))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    RUNNING = <span class="string">'running'</span></span><br><span class="line">    WAITING = <span class="string">'waiting'</span></span><br><span class="line">    BLOCKED = <span class="string">'blocked'</span></span><br><span class="line">    TERMINATED = <span class="string">'terminated'</span></span><br><span class="line">    p1, p2 = Process(<span class="string">'process1'</span>), Process(<span class="string">'process2'</span>)</span><br><span class="line">    [state_info(p) <span class="keyword">for</span> p <span class="keyword">in</span> (p1, p2)]</span><br><span class="line"></span><br><span class="line">    print()</span><br><span class="line">    transition(p1, p1.wait, WAITING)</span><br><span class="line">    transition(p2, p2.terminate, TERMINATED)</span><br><span class="line">    [state_info(p) <span class="keyword">for</span> p <span class="keyword">in</span> (p1, p2)]</span><br><span class="line">    print()</span><br><span class="line">    transition(p1, p1.run, RUNNING)</span><br><span class="line">    transition(p2, p2.wait, WAITING)</span><br><span class="line">    [state_info(p) <span class="keyword">for</span> p <span class="keyword">in</span> (p1, p2)]</span><br><span class="line">    print()</span><br><span class="line">    transition(p2, p2.run, RUNNING)</span><br><span class="line">    [state_info(p) <span class="keyword">for</span> p <span class="keyword">in</span> (p1, p2)]</span><br><span class="line">    print()</span><br><span class="line">    [transition(p, p.block, BLOCKED) <span class="keyword">for</span> p <span class="keyword">in</span> (p1, p2)]</span><br><span class="line">    [state_info(p) <span class="keyword">for</span> p <span class="keyword">in</span> (p1, p2)]</span><br><span class="line">    print()</span><br><span class="line">    [transition(p, p.terminate, TERMINATED) <span class="keyword">for</span> p <span class="keyword">in</span> (p1, p2)]</span><br><span class="line">    [state_info(p) <span class="keyword">for</span> p <span class="keyword">in</span> (p1, p2)]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;状态模式是一个或多个有限状态机（简称状态机）的实现，用于解决一个特定的软件工程问题。&lt;/p&gt;
&lt;p&gt;状态机是一个抽象机器，具有两个主要部分：状态和转换。状态是指一个系统的当前状况。一个状态机在任意时间点只会有一个激活状态。转换是指从当前状态到一个新状态的切换。在一个转换发生之前或之后通常会执行一个或多个动作。状态机可以使用状态图进行视觉上的展现。&lt;/p&gt;
&lt;p&gt;状态机用于解决许多计算机问题和非计算机问题，其中包括交通灯、停车计时器、硬件设计和编程语言解析等。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://lovemma.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Python" scheme="https://lovemma.github.io/tags/Python/"/>
    
      <category term="设计模式" scheme="https://lovemma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="https://lovemma.github.io/2018/10/29/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lovemma.github.io/2018/10/29/观察者模式/</id>
    <published>2018-10-29T12:04:55.000Z</published>
    <updated>2018-10-29T12:05:49.358Z</updated>
    
    <content type="html"><![CDATA[<p>观察者模式用在当一个对象的状态变更需要通知其他很多对象的时候，比如rss订阅或者在社交网站上订阅某个频道的更新。事件驱动系统也是一种发布订阅模式，事件作为发布者，监听器作为订阅者，只不过这里多个事件监听器可以监听同一个事件。 我们这里实现一个“Data Formatter”来解释发布订阅模式，一种数据可以有多个格式化Formatter，当数据更新的时候，会通知所有的Formatter格式化新的数据。使用继承来实现。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.observers = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, observer)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> observer <span class="keyword">not</span> <span class="keyword">in</span> self.observers:</span><br><span class="line">            self.observers.append(observer)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'Failed to add : &#123;&#125;'</span>).format(observer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, observer)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.observers.remove(observer)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            print(<span class="string">'Failed to remove : &#123;&#125;'</span>).format(observer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(self)</span>:</span></span><br><span class="line">        [o.notify_by(self) <span class="keyword">for</span> o <span class="keyword">in</span> self.observers]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultFormatter</span><span class="params">(Publisher)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line">        self._data = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;&#125;: '&#123;&#125;' has data = &#123;&#125;"</span>.format(</span><br><span class="line">            type(self).__name__, self.name, self._data)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._data</span><br><span class="line"></span><br><span class="line"><span class="meta">    @data.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span><span class="params">(self, new_value)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._data = int(new_value)</span><br><span class="line">        <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">'Error: &#123;&#125;'</span>.format(e))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.notify()    <span class="comment"># data 在被合法赋值以后会执行notify</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HexFormatter</span>:</span></span><br><span class="line">    <span class="string">""" 订阅者 """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify_by</span><span class="params">(self, publisher)</span>:</span></span><br><span class="line">        print(<span class="string">"&#123;&#125;: '&#123;&#125;' has now hex data = &#123;&#125;"</span>.format(</span><br><span class="line">            type(self).__name__, publisher.name, hex(publisher.data)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryFormatter</span>:</span></span><br><span class="line">    <span class="string">""" 订阅者 """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify_by</span><span class="params">(self, publisher)</span>:</span></span><br><span class="line">        print(<span class="string">"&#123;&#125;: '&#123;&#125;' has now bin data = &#123;&#125;"</span>.format(</span><br><span class="line">            type(self).__name__, publisher.name, bin(publisher.data)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    df = DefaultFormatter(<span class="string">'test1'</span>)</span><br><span class="line">    print(df)</span><br><span class="line">    print()</span><br><span class="line">    hf = HexFormatter()</span><br><span class="line">    df.add(hf)</span><br><span class="line">    df.data = <span class="number">3</span></span><br><span class="line">    print(df)</span><br><span class="line"></span><br><span class="line">    print()</span><br><span class="line">    bf = BinaryFormatter()</span><br><span class="line">    df.add(bf)</span><br><span class="line">    df.data = <span class="number">21</span></span><br><span class="line">    print(df)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;观察者模式用在当一个对象的状态变更需要通知其他很多对象的时候，比如rss订阅或者在社交网站上订阅某个频道的更新。事件驱动系统也是一种发布订阅模式，事件作为发布者，监听器作为订阅者，只不过这里多个事件监听器可以监听同一个事件。 我们这里实现一个“Data Formatter”来解释发布订阅模式，一种数据可以有多个格式化Formatter，当数据更新的时候，会通知所有的Formatter格式化新的数据。使用继承来实现。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://lovemma.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Python" scheme="https://lovemma.github.io/tags/Python/"/>
    
      <category term="设计模式" scheme="https://lovemma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式:解释器模式</title>
    <link href="https://lovemma.github.io/2018/10/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lovemma.github.io/2018/10/28/设计模式-解释器模式/</id>
    <published>2018-10-28T07:06:34.000Z</published>
    <updated>2018-10-28T07:07:26.896Z</updated>
    
    <content type="html"><![CDATA[<p>解释器模式用于为高级用户和领域专家提供一个类编程的框架，但没有暴露出编程语言那样的复杂性。这是通过实现一个DSL来达到目的的。</p><p>DSL是一种针对特定领域、表达能力有限的计算机语言。 DSL有两类，分别是内部DSL和外部DSL。内部DSL构建在一种宿主编程语言之上，依赖宿主编程语言，外部DSL则是从头实现，不依赖某种已有的编程语言。解释器模式仅与内部DSL相关。</p><p>例如：乐谱是一个非软件DSL的例子。音乐演奏者像一个解释器那样，使用乐谱演奏出音乐。</p><a id="more"></a><p>我们可以使用<code>Pyparsing</code>创建一种DSL来控制大门（PS：使用一个好的解析工具以模式匹配来解释结果更加简单）。示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyparsing <span class="keyword">import</span> Word, OneOrMore, Optional, Group, Suppress, alphanums</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gate</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.is_open = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'open'</span> <span class="keyword">if</span> self.is_open <span class="keyword">else</span> <span class="string">'closed'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'opening the gate'</span>)</span><br><span class="line">        self.is_open = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'closing the gate'</span>)</span><br><span class="line">        self.is_open = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 首先定义我们的DSL格式，我们这里最简单的控制语法就是   "open -&gt; gate"</span></span><br><span class="line">    word = Word(alphanums)</span><br><span class="line">    command = Group(OneOrMore(word))</span><br><span class="line">    token = Suppress(<span class="string">"-&gt;"</span>)</span><br><span class="line">    device = Group(OneOrMore(word))</span><br><span class="line">    argument = Group(OneOrMore(word))</span><br><span class="line">    event = command + token + device + Optional(token + argument)</span><br><span class="line"></span><br><span class="line">    gate = Gate()</span><br><span class="line">    cmds = [<span class="string">'open -&gt; gate'</span>, <span class="string">'close -&gt; gate'</span>]    <span class="comment"># 两个自定义的命令</span></span><br><span class="line">    open_actions = &#123;<span class="string">'gate'</span>: gate.open&#125;</span><br><span class="line">    close_actions = &#123;<span class="string">'gate'</span>: gate.close&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> cmd <span class="keyword">in</span> cmds:</span><br><span class="line">        print(event.parseString(cmd))    <span class="comment"># [['open'], ['gate']]</span></span><br><span class="line">        cmd, dev = event.parseString(cmd)</span><br><span class="line">        cmd_str, dev_str = <span class="string">' '</span>.join(cmd), <span class="string">' '</span>.join(dev)</span><br><span class="line">        print(cmd_str, dev_str)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'open'</span> <span class="keyword">in</span> cmd_str:</span><br><span class="line">            open_actions[dev_str]()</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'close'</span> <span class="keyword">in</span> cmd_str:</span><br><span class="line">            close_actions[dev_str]()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><p>这样就实现了一个简单的大门控制语言，只是功能很弱。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解释器模式用于为高级用户和领域专家提供一个类编程的框架，但没有暴露出编程语言那样的复杂性。这是通过实现一个DSL来达到目的的。&lt;/p&gt;
&lt;p&gt;DSL是一种针对特定领域、表达能力有限的计算机语言。 DSL有两类，分别是内部DSL和外部DSL。内部DSL构建在一种宿主编程语言之上，依赖宿主编程语言，外部DSL则是从头实现，不依赖某种已有的编程语言。解释器模式仅与内部DSL相关。&lt;/p&gt;
&lt;p&gt;例如：乐谱是一个非软件DSL的例子。音乐演奏者像一个解释器那样，使用乐谱演奏出音乐。&lt;/p&gt;
    
    </summary>
    
      <category term="解释器模式" scheme="https://lovemma.github.io/categories/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Python" scheme="https://lovemma.github.io/tags/Python/"/>
    
      <category term="解释器模式" scheme="https://lovemma.github.io/tags/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之命令模式</title>
    <link href="https://lovemma.github.io/2018/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lovemma.github.io/2018/10/24/设计模式之命令模式/</id>
    <published>2018-10-24T14:33:54.000Z</published>
    <updated>2018-10-24T14:34:26.448Z</updated>
    
    <content type="html"><![CDATA[<p>命令设计模式帮助我们将一个操作（撤销、重做、复制、粘贴等）封装成一个对象，通常是创建一个包含Operation所有逻辑和方法的类。</p><p>当我们去餐馆吃饭时，会叫服务员来点单。他们用来做记录的账单（通常是纸质的）就是命令模式的一个例子。在记录好订单后，服务员将其放入账单队列，厨师会照着单子去做。每个账单都是独立的，并且可用来执行许多不同命令，例如，一个命令对应一个将要烹饪的菜品。</p><p>通过命令模式可以控制命令的执行时间和过程，还可以用来组织事务。 </p><a id="more"></a><p>这里用一些文件操作类来说明命令模式的使用:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">verbose = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenameFile</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, path_src, path_dest)</span>:</span></span><br><span class="line">        self.src, self.dest = path_src, path_dest</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            print(<span class="string">"[renaming '&#123;&#125;' to '&#123;&#125;']"</span>.format(self.src, self.dest))</span><br><span class="line">        os.rename(self.src, self.dest)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">undo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            print(<span class="string">"[renaming '&#123;&#125;' back to '&#123;&#125;']"</span>.format(self.dest, self.src))</span><br><span class="line">        os.rename(self.dest, self.src)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateFile</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, path, txt=<span class="string">'hello world\n'</span>)</span>:</span></span><br><span class="line">        self.path, self.txt = path, txt</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            print(<span class="string">"[creating file '&#123;&#125;']"</span>.format(self.path))</span><br><span class="line">        <span class="keyword">with</span> open(self.path, mode=<span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> out_file:</span><br><span class="line">            out_file.write(self.txt)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">undo</span><span class="params">(self)</span>:</span></span><br><span class="line">        delete_file(self.path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadFile</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, path)</span>:</span></span><br><span class="line">        self.path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            print(<span class="string">"[reading file '&#123;&#125;']"</span>.format(self.path))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> open(self.path, mode=<span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> in_file:</span><br><span class="line">            print(in_file.read(), end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_file</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> verbose:</span><br><span class="line">        print(<span class="string">"deleting file '&#123;&#125;'"</span>.format(path))</span><br><span class="line">    os.remove(path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    orig_name, new_name = <span class="string">'file1'</span>, <span class="string">'file2'</span></span><br><span class="line">    commands = []</span><br><span class="line">    <span class="keyword">for</span> cmd <span class="keyword">in</span> CreateFile(orig_name), ReadFile(orig_name), RenameFile(orig_name, new_name):</span><br><span class="line">        commands.append(cmd)</span><br><span class="line">    [c.execute() <span class="keyword">for</span> c <span class="keyword">in</span> commands]</span><br><span class="line"></span><br><span class="line">    answer = input(<span class="string">'reverse the executed commands? [y/n] '</span>)</span><br><span class="line">    <span class="keyword">if</span> answer <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'yY'</span>:</span><br><span class="line">        print(<span class="string">"the result is &#123;&#125;"</span>.format(new_name))</span><br><span class="line">        exit()</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> reversed(commands):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            c.undo()</span><br><span class="line">        <span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;命令设计模式帮助我们将一个操作（撤销、重做、复制、粘贴等）封装成一个对象，通常是创建一个包含Operation所有逻辑和方法的类。&lt;/p&gt;
&lt;p&gt;当我们去餐馆吃饭时，会叫服务员来点单。他们用来做记录的账单（通常是纸质的）就是命令模式的一个例子。在记录好订单后，服务员将其放入账单队列，厨师会照着单子去做。每个账单都是独立的，并且可用来执行许多不同命令，例如，一个命令对应一个将要烹饪的菜品。&lt;/p&gt;
&lt;p&gt;通过命令模式可以控制命令的执行时间和过程，还可以用来组织事务。 &lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://lovemma.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Python" scheme="https://lovemma.github.io/tags/Python/"/>
    
      <category term="设计模式" scheme="https://lovemma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之责任链模式</title>
    <link href="https://lovemma.github.io/2018/10/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lovemma.github.io/2018/10/23/设计模式之责任链模式/</id>
    <published>2018-10-23T12:02:16.000Z</published>
    <updated>2018-10-23T12:02:42.145Z</updated>
    
    <content type="html"><![CDATA[<p>责任链（Chain of Responsibility）模式用于让多个对象来处理单个请求，或者用于预先不知道应该由哪个对象（来自某个对象链）来处理某个特定请求。我们可以使用计算机网络的广播来类比责任链模式。</p><p>在责任链模式中，发送方可直接访问链中的首个节点。若首个节点不能处理请求，则转发给下一个节点，如此直到请求被某个节点处理或者整个链遍历结束。这种设计模式用于实现发送方与接收方（多个）之间的解耦。<br><a id="more"></a></p><p>这里以一个事件驱动的例子来做说明：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""Docstring for Widget. """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None)</span>:</span></span><br><span class="line">        self.parent = parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self, event)</span>:</span></span><br><span class="line">        handler = <span class="string">'handle_&#123;&#125;'</span>.format(event)</span><br><span class="line">        <span class="keyword">if</span> hasattr(self, handler):</span><br><span class="line">            method = getattr(self, handler)</span><br><span class="line">            method(event)</span><br><span class="line">        <span class="keyword">elif</span> self.parent:</span><br><span class="line">            self.parent.handle(event)</span><br><span class="line">        <span class="keyword">elif</span> hasattr(self, <span class="string">'handle_default'</span>):</span><br><span class="line">            self.handle_default(event)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(Widget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_close</span><span class="params">(self, event)</span>:</span></span><br><span class="line">        print(<span class="string">'MainWindow: &#123;&#125;'</span>.format(event))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_default</span><span class="params">(self, event)</span>:</span></span><br><span class="line">        print(<span class="string">'MainWindow: Default &#123;&#125;'</span>.format(event))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendDialog</span><span class="params">(Widget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_paint</span><span class="params">(self, event)</span>:</span></span><br><span class="line">        print(<span class="string">'SendDialog: &#123;&#125;'</span>.format(event))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgText</span><span class="params">(Widget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_down</span><span class="params">(self, event)</span>:</span></span><br><span class="line">        print(<span class="string">'MsgText: &#123;&#125;'</span>.format(event))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    mw = MainWindow()</span><br><span class="line">    sd = SendDialog(mw)    <span class="comment"># parent是mw</span></span><br><span class="line">    msg = MsgText(sd)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> (<span class="string">'down'</span>, <span class="string">'paint'</span>, <span class="string">'unhandled'</span>, <span class="string">'close'</span>):</span><br><span class="line">        evt = Event(e)</span><br><span class="line">        print(<span class="string">'\nSending event -&#123;&#125;- to MainWindow'</span>.format(evt))</span><br><span class="line">        mw.handle(evt)</span><br><span class="line">        print(<span class="string">'Sending event -&#123;&#125;- to SendDialog'</span>.format(evt))</span><br><span class="line">        sd.handle(evt)</span><br><span class="line">        print(<span class="string">'Sending event -&#123;&#125;- to MsgText'</span>.format(evt))</span><br><span class="line">        msg.handle(evt)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;责任链（Chain of Responsibility）模式用于让多个对象来处理单个请求，或者用于预先不知道应该由哪个对象（来自某个对象链）来处理某个特定请求。我们可以使用计算机网络的广播来类比责任链模式。&lt;/p&gt;
&lt;p&gt;在责任链模式中，发送方可直接访问链中的首个节点。若首个节点不能处理请求，则转发给下一个节点，如此直到请求被某个节点处理或者整个链遍历结束。这种设计模式用于实现发送方与接收方（多个）之间的解耦。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://lovemma.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Python" scheme="https://lovemma.github.io/tags/Python/"/>
    
      <category term="设计模式" scheme="https://lovemma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之代理模式</title>
    <link href="https://lovemma.github.io/2018/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lovemma.github.io/2018/10/22/设计模式之代理模式/</id>
    <published>2018-10-22T14:06:07.000Z</published>
    <updated>2018-10-22T14:07:03.486Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式是通过一层间接保护层实现更安全的接口访问，例如：访问敏感信息——在允许用户访问敏感信息之前，我们希望确保用户具备足够的权限。</p><p>有四种常用的代理模式：</p><ul><li>远程代理：实际存在于不同地址空间（例如，某个网络服务器）的对象在本地的代理者。使得访问远程对象就像访问本地一样，隐藏了复杂性，如：ORM。</li><li>虚拟代理：用来实现延迟访问，比如一些需要复杂计算的对象，Python 里可以实现 lazy_property，改善性能。</li><li>保护/防护代理：用于控制敏感对象的访问。</li><li>智能(引用)代理：在对象被访问时执行额外的动作。例如引用计数和线程安全检查。</li></ul><a id="more"></a><h2 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h2><p>我们先创建一个<code>LazyProperty</code>类，用作一个装饰器。当它修饰某个特性时，<code>LazyProperty</code> 惰性地（首次使用时）加载特性，而不是立即进行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyProperty</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, method)</span>:</span></span><br><span class="line">        self.method = method</span><br><span class="line">        self.method_name = method.__name__</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> instance:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        value = self.method(instance)</span><br><span class="line">        setattr(owner, self.method_name, value)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = <span class="string">'foo'</span></span><br><span class="line">        self.y = <span class="string">'bar'</span></span><br><span class="line">        self._resource = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @LazyProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">resource</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 构造函数里没有初始化，第一次访问才会被调用</span></span><br><span class="line">        print(<span class="string">'initializing self._resource which is: &#123;&#125;'</span>.format(self._resource))</span><br><span class="line">        self._resource = tuple(range(<span class="number">5</span>))  <span class="comment"># 模拟一次耗时计算</span></span><br><span class="line">        <span class="keyword">return</span> self._resource</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    t = Test()</span><br><span class="line">    print(t.x)</span><br><span class="line">    print(t.y)</span><br><span class="line">    <span class="comment"># 访问LazyProperty, resource里的print语句只执行一次，实现了延迟加载和一次执行</span></span><br><span class="line">    print(t.resource)</span><br><span class="line">    print(t.resource)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>LazyProperty类实际上是一个描述符。 描述符（descriptor）是Python中重写类属性访问方法（<code>__get__()</code>、 <code>__set__()</code>和<code>__delete__()</code>）的默认行为要使用的一种推荐机制。<br>Test类演示了我们可以如何使用LazyProperty类。其中有三个属性， x、 y 和 _resource。我们想懒加载 _resource 变量，因此将其初始化为None。</p><p>在OOP中有两种基本的、不同类型的懒加载，如下所示：</p><ul><li>在实例级：这意味着会一个对象的特性进行懒初始化，但该特性有一个对象作用域。同一个类的每个实例（对象）都有自己的（不同的）特性副本。</li><li>在类级或模块级：在这种情况下，我们不希望每个实例都有一个不同的特性副本，而是所有实例共享同一个特性，而特性是懒初始化的。</li></ul><h2 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h2><p>这里实现一个简单的保护代理来查看和添加用户，该服务提供以下两个选项：</p><ul><li>查看用户列表：这一操作不要求特殊权限。</li><li>添加新用户：这一操作要求客户端提供一个特殊的密码。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensitiveInfo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.users = [<span class="string">'nick'</span>, <span class="string">'tom'</span>, <span class="string">'ben'</span>, <span class="string">'mike'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = <span class="string">'There are &#123;&#125; users: &#123;&#125;'</span></span><br><span class="line">        print(result.format(len(self.users), <span class="string">' '</span>.join(self.users)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, user)</span>:</span></span><br><span class="line">        self.users.append(user)</span><br><span class="line">        print(<span class="string">'Added user &#123;&#125;'</span>.format(user))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.protected = SensitiveInfo()</span><br><span class="line">        self.secret = <span class="string">'0xdeadbeef'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.protected.read()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, user)</span>:</span></span><br><span class="line">        sec = input(<span class="string">'what is the secret? '</span>)</span><br><span class="line">        self.protected.add(user) <span class="keyword">if</span> sec == self.secret <span class="keyword">else</span> print(<span class="string">"That's wrong!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    info = Info()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'1. read list |==| 2. add user |==| 3. quit'</span>)</span><br><span class="line">        key = input(<span class="string">'choose option: '</span>)</span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">'1'</span>:</span><br><span class="line">            info.read()</span><br><span class="line">        <span class="keyword">elif</span> key == <span class="string">'2'</span>:</span><br><span class="line">            name = input(<span class="string">'choose username: '</span>)</span><br><span class="line">            info.add(name)</span><br><span class="line">        <span class="keyword">elif</span> key == <span class="string">'3'</span>:</span><br><span class="line">            exit()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'unknown option: &#123;&#125;'</span>.format(key))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>该示例有几个重大的安全缺陷：</p><ol><li>没有什么能阻止客户端代码通过直接创建一个 SensitiveInfo 实例来绕过应用的安全设置，疑使用 <strong>abc</strong> 模块来禁止直接实例化 SensitiveInfo。</li><li>密钥直接写死在代码里，应该用安全性较高密钥写到配置或者环境变量里。</li></ol><p>这里使用抽象基类来修复第一个问题，只需要修改类代码而不用修改 main() 函数里面的使用代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensitiveInfo</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.users = [<span class="string">'nick'</span>, <span class="string">'tom'</span>, <span class="string">'ben'</span>, <span class="string">'mike'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, user)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span><span class="params">(SensitiveInfo)</span>:</span></span><br><span class="line">    <span class="string">'''protection proxy to SensitiveInfo'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># self.protected = SensitiveInfo()</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.secret = <span class="string">'0xdeadbeef'</span>    <span class="comment"># 为了方便示例这里直接写死在代码里</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'There are &#123;&#125; users: &#123;&#125;'</span>.format(len(self.users), <span class="string">' '</span>.join(self.users)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, user)</span>:</span></span><br><span class="line">        <span class="string">""" 给add操作加上密钥验证，保护add操作"""</span></span><br><span class="line">        sec = input(<span class="string">'what is the secret? '</span>)</span><br><span class="line">        self.users.append(user) <span class="keyword">if</span> sec == self.secret <span class="keyword">else</span> print(<span class="string">"That's wrong!"</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理模式是通过一层间接保护层实现更安全的接口访问，例如：访问敏感信息——在允许用户访问敏感信息之前，我们希望确保用户具备足够的权限。&lt;/p&gt;
&lt;p&gt;有四种常用的代理模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;远程代理：实际存在于不同地址空间（例如，某个网络服务器）的对象在本地的代理者。使得访问远程对象就像访问本地一样，隐藏了复杂性，如：ORM。&lt;/li&gt;
&lt;li&gt;虚拟代理：用来实现延迟访问，比如一些需要复杂计算的对象，Python 里可以实现 lazy_property，改善性能。&lt;/li&gt;
&lt;li&gt;保护/防护代理：用于控制敏感对象的访问。&lt;/li&gt;
&lt;li&gt;智能(引用)代理：在对象被访问时执行额外的动作。例如引用计数和线程安全检查。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://lovemma.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Python" scheme="https://lovemma.github.io/tags/Python/"/>
    
      <category term="设计模式" scheme="https://lovemma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
